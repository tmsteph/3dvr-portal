<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3DVR - Jetpack Ski Prototype</title>
  <link rel="stylesheet" href="styles/global.css">
  <style>
  body {
    margin: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    background: radial-gradient(circle at 20% -10%, #182848 0%, #090a0f 60%, #040508 100%);
    color: #e8f1ff;
  }

  h1 {
    margin: 0 0 0.5rem;
    text-align: center;
    font-size: clamp(2rem, 3.4vw, 3rem);
  }

  p.description {
    margin: 0 0 1.5rem;
    max-width: 720px;
    text-align: center;
    color: rgba(226, 232, 240, 0.8);
  }

  canvas {
    width: min(960px, 90vw);
    height: auto;
    border-radius: 18px;
    border: 1px solid rgba(148, 163, 184, 0.32);
    background: rgba(9, 11, 19, 0.75);
    box-shadow: 0 32px 80px rgba(8, 15, 30, 0.55);
  }

  .hud {
    margin-top: 1rem;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    width: min(960px, 90vw);
    background: rgba(9, 14, 30, 0.7);
    border: 1px solid rgba(99, 102, 241, 0.4);
    border-radius: 16px;
    padding: 1rem 1.25rem;
    box-shadow: 0 20px 60px rgba(4, 10, 24, 0.65);
  }

  .hud section {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }

  .bar {
    height: 10px;
    border-radius: 999px;
    background: rgba(148, 163, 184, 0.25);
    overflow: hidden;
  }

  .bar span {
    display: block;
    height: 100%;
    border-radius: inherit;
    transition: width 0.2s ease;
  }

  ul.controls {
    margin: 0;
    padding-left: 1.2rem;
  }

  ul.controls li {
    margin-bottom: 0.2rem;
  }

  .stat {
    font-size: 1.1rem;
    font-weight: 600;
  }
  </style>
</head>
<body class="theme-dark">
  <div class="top-buttons">
    <a href="index.html">üè† Portal</a>
    <a href="games.html">üéÆ Game Hub</a>
    <a href="https://3dvr.tech/#subscribe" target="_blank" rel="noopener">‚≠ê Subscribe</a>
    <a href="https://github.com/tmsteph/3dvr-portal" target="_blank" rel="noopener">üöÄ GitHub</a>
  </div>
  <main>
    <h1>Zero-G Ski Range</h1>
    <p class="description">Chain skiing, sustained jetpack lines, and hybrid weapons converge in this first physics prototype inspired by Tribes: Aerial Assault. Use the arena to dial-in timing between slope acceleration, vertical thrust, and the iconic spinfusor + chaingun combo.</p>
    <canvas id="game" width="960" height="540" role="img" aria-label="Jetpack skiing playground"></canvas>
    <div class="hud">
      <section>
        <span class="stat">Energy <span id="energy-value">100</span>%</span>
        <div class="bar" aria-hidden="true">
          <span id="energy-bar" style="background: linear-gradient(90deg, #22d3ee, #60a5fa); width: 100%;"></span>
        </div>
        <span class="stat">Velocity <span id="velocity-value">0</span> m/s</span>
      </section>
      <section>
        <span class="stat">Weapon: <span id="weapon-name">Spinfusor</span></span>
        <span>Hits Landed: <span id="hit-count">0</span></span>
        <span>Target Integrity: <span id="target-health">100</span>%</span>
      </section>
      <section>
        <span class="stat">Controls</span>
        <ul class="controls">
          <li><strong>A / D</strong> lean into the slope</li>
          <li><strong>Shift</strong> hold to engage jetpack</li>
          <li><strong>1</strong> Spinfusor (energy disk)</li>
          <li><strong>2</strong> Chaingun (ballistic)</li>
          <li><strong>Left click</strong> fire | <strong>Right click</strong> air-brake</li>
        </ul>
      </section>
    </div>
  </main>
  <script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const energyBar = document.getElementById('energy-bar');
  const energyValue = document.getElementById('energy-value');
  const velocityValue = document.getElementById('velocity-value');
  const weaponName = document.getElementById('weapon-name');
  const hitCountEl = document.getElementById('hit-count');
  const targetHealthEl = document.getElementById('target-health');

  const gravity = 0.45;
  const jetpackForce = 0.9;
  const jetpackDrain = 0.7;
  const groundThrust = 0.25;
  const airControl = 0.12;
  const groundFriction = 0.993;
  const rechargeGround = 0.9;
  const rechargeAir = 0.25;

  const input = {
    left: false,
    right: false,
    jetpack: false,
    fire: false,
    brake: false,
    mouseX: canvas.width / 2,
    mouseY: canvas.height / 2
  };

  const player = {
    x: 180,
    y: groundHeight(180) - 30,
    vx: 0,
    vy: 0,
    radius: 16,
    energy: 100,
    maxEnergy: 100,
    onGround: false,
    weaponIndex: 0,
    fireCooldown: 0
  };

  const weapons = [
    {
      name: 'Spinfusor',
      fireRate: 28,
      muzzleSpeed: 9,
      energyCost: 12,
      spread: 0,
      color: '#60a5fa',
      radius: 9,
      drag: 0.996,
      gravityScale: 0.12,
      impactDamage: 40
    },
    {
      name: 'Chaingun',
      fireRate: 6,
      muzzleSpeed: 16,
      energyCost: 0,
      spread: 0.1,
      color: '#facc15',
      radius: 4,
      drag: 0.995,
      gravityScale: 0.02,
      impactDamage: 6
    }
  ];

  const projectiles = [];

  const target = {
    x: 680,
    y: groundHeight(680) - 90,
    width: 40,
    height: 90,
    health: 100,
    regenDelay: 0,
    sway: 0
  };

  let hitsLanded = 0;

  function groundHeight(x) {
    const wave1 = Math.sin((x + 80) * 0.008) * 60;
    const wave2 = Math.sin((x - 240) * 0.017) * 28;
    return canvas.height - 110 + wave1 + wave2;
  }

  function groundSlope(x) {
    const wave1 = Math.cos((x + 80) * 0.008) * 0.008 * 60;
    const wave2 = Math.cos((x - 240) * 0.017) * 0.017 * 28;
    return wave1 + wave2;
  }

  function handleInputDown(event) {
    if (event.repeat) {
      return;
    }
    if (event.code === 'KeyA') {
      input.left = true;
    }
    if (event.code === 'KeyD') {
      input.right = true;
    }
    if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
      input.jetpack = true;
    }
    if (event.code === 'Digit1') {
      player.weaponIndex = 0;
      weaponName.textContent = weapons[0].name;
    }
    if (event.code === 'Digit2') {
      player.weaponIndex = 1;
      weaponName.textContent = weapons[1].name;
    }
  }

  function handleInputUp(event) {
    if (event.code === 'KeyA') {
      input.left = false;
    }
    if (event.code === 'KeyD') {
      input.right = false;
    }
    if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
      input.jetpack = false;
    }
  }

  function handleMouseDown(event) {
    if (event.button === 0) {
      input.fire = true;
    }
    if (event.button === 2) {
      input.brake = true;
    }
  }

  function handleMouseUp(event) {
    if (event.button === 0) {
      input.fire = false;
    }
    if (event.button === 2) {
      input.brake = false;
    }
  }

  function updateMousePosition(event) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    input.mouseX = (event.clientX - rect.left) * scaleX;
    input.mouseY = (event.clientY - rect.top) * scaleY;
  }

  document.addEventListener('keydown', handleInputDown);
  document.addEventListener('keyup', handleInputUp);
  canvas.addEventListener('mousedown', handleMouseDown);
  canvas.addEventListener('mouseup', handleMouseUp);
  canvas.addEventListener('mouseleave', () => {
    input.fire = false;
    input.brake = false;
  });
  canvas.addEventListener('contextmenu', event => event.preventDefault());
  canvas.addEventListener('mousemove', updateMousePosition);

  function updatePlayer() {
    player.vx += (input.right ? airControl : 0) - (input.left ? airControl : 0);
    player.vy += gravity;

    const groundY = groundHeight(player.x);
    if (player.y >= groundY - player.radius) {
      player.y = groundY - player.radius;
      player.onGround = true;
      player.vy = Math.min(player.vy, 0);
      const slope = groundSlope(player.x);
      player.vx += -slope * gravity * 0.75;
      player.vx += (input.right ? groundThrust : 0) - (input.left ? groundThrust : 0);
      if (input.brake) {
        player.vx *= 0.9;
      } else {
        player.vx *= groundFriction;
      }
      player.energy = Math.min(player.maxEnergy, player.energy + rechargeGround);
    } else {
      player.onGround = false;
      if (input.jetpack && player.energy > 0) {
        player.vy -= jetpackForce;
        player.energy = Math.max(0, player.energy - jetpackDrain);
      } else {
        player.energy = Math.min(player.maxEnergy, player.energy + rechargeAir);
      }
      if (input.brake && player.vy > 0) {
        player.vy *= 0.92;
      }
    }

    player.x += player.vx;
    player.y += player.vy;

    if (player.x < 20) {
      player.x = 20;
      player.vx *= -0.2;
    }
    if (player.x > canvas.width - 20) {
      player.x = canvas.width - 20;
      player.vx *= -0.2;
    }

    energyBar.style.width = `${(player.energy / player.maxEnergy) * 100}%`;
    energyValue.textContent = Math.round(player.energy);
    velocityValue.textContent = Math.abs(player.vx).toFixed(1);
  }

  function fireWeapon() {
    const weapon = weapons[player.weaponIndex];
    if (player.fireCooldown > 0) {
      player.fireCooldown -= 1;
      return;
    }
    if (!input.fire) {
      return;
    }
    if (player.energy < weapon.energyCost) {
      return;
    }

    const angle = Math.atan2(input.mouseY - player.y, input.mouseX - player.x) + ((Math.random() - 0.5) * weapon.spread);
    const projectile = {
      x: player.x + Math.cos(angle) * (player.radius + 4),
      y: player.y + Math.sin(angle) * (player.radius + 4),
      vx: Math.cos(angle) * weapon.muzzleSpeed + player.vx * 0.35,
      vy: Math.sin(angle) * weapon.muzzleSpeed + player.vy * 0.35,
      radius: weapon.radius,
      color: weapon.color,
      drag: weapon.drag,
      gravityScale: weapon.gravityScale,
      damage: weapon.impactDamage,
      alive: true
    };
    projectiles.push(projectile);
    player.fireCooldown = weapon.fireRate;
    player.energy = Math.max(0, player.energy - weapon.energyCost);
  }

  function updateProjectiles() {
    for (const projectile of projectiles) {
      if (!projectile.alive) {
        continue;
      }
      projectile.vx *= projectile.drag;
      projectile.vy = projectile.vy * projectile.drag + gravity * projectile.gravityScale;
      projectile.x += projectile.vx;
      projectile.y += projectile.vy;

      const groundY = groundHeight(projectile.x);
      if (projectile.y + projectile.radius >= groundY) {
        projectile.alive = false;
        continue;
      }

      if (
        projectile.x + projectile.radius > target.x &&
        projectile.x - projectile.radius < target.x + target.width &&
        projectile.y + projectile.radius > target.y &&
        projectile.y - projectile.radius < target.y + target.height
      ) {
        projectile.alive = false;
        hitsLanded += 1;
        target.health = Math.max(0, target.health - projectile.damage);
        target.regenDelay = 220;
        hitCountEl.textContent = hitsLanded;
        targetHealthEl.textContent = Math.round(target.health);
      }

      if (
        projectile.x < -60 ||
        projectile.x > canvas.width + 60 ||
        projectile.y < -100 ||
        projectile.y > canvas.height + 100
      ) {
        projectile.alive = false;
      }
    }
  }

  function updateTarget() {
    target.sway += 0.015;
    const swayOffset = Math.sin(target.sway) * 12;
    target.x = 680 + swayOffset;
    if (target.regenDelay > 0) {
      target.regenDelay -= 1;
    } else {
      target.health = Math.min(100, target.health + 0.05);
      targetHealthEl.textContent = target.health.toFixed(0);
    }
  }

  function cleanupProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i -= 1) {
      if (!projectiles[i].alive) {
        projectiles.splice(i, 1);
      }
    }
  }

  function drawTerrain() {
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    for (let x = 0; x <= canvas.width; x += 4) {
      ctx.lineTo(x, groundHeight(x));
    }
    ctx.lineTo(canvas.width, canvas.height);
    ctx.closePath();
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, 'rgba(56, 189, 248, 0.08)');
    gradient.addColorStop(0.7, 'rgba(15, 23, 42, 0.85)');
    gradient.addColorStop(1, 'rgba(2, 6, 23, 0.95)');
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(94, 234, 212, 0.3)';
    ctx.stroke();
  }

  function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = '#f8fafc';
    ctx.beginPath();
    ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(125, 211, 252, 0.9)';
    ctx.lineWidth = 2;
    ctx.stroke();

    if (!player.onGround && input.jetpack && player.energy > 0) {
      ctx.beginPath();
      ctx.moveTo(-6, player.radius - 2);
      ctx.lineTo(-12, player.radius + 24 + Math.random() * 6);
      ctx.moveTo(6, player.radius - 2);
      ctx.lineTo(12, player.radius + 24 + Math.random() * 6);
      ctx.strokeStyle = 'rgba(56, 189, 248, 0.8)';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawProjectiles() {
    for (const projectile of projectiles) {
      if (!projectile.alive) {
        continue;
      }
      ctx.beginPath();
      ctx.fillStyle = projectile.color;
      ctx.globalAlpha = 0.92;
      ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function drawTarget() {
    ctx.save();
    ctx.fillStyle = 'rgba(244, 114, 182, 0.7)';
    ctx.strokeStyle = 'rgba(236, 72, 153, 0.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    const r = 12;
    ctx.moveTo(target.x + r, target.y);
    ctx.lineTo(target.x + target.width - r, target.y);
    ctx.quadraticCurveTo(target.x + target.width, target.y, target.x + target.width, target.y + r);
    ctx.lineTo(target.x + target.width, target.y + target.height - r);
    ctx.quadraticCurveTo(target.x + target.width, target.y + target.height, target.x + target.width - r, target.y + target.height);
    ctx.lineTo(target.x + r, target.y + target.height);
    ctx.quadraticCurveTo(target.x, target.y + target.height, target.x, target.y + target.height - r);
    ctx.lineTo(target.x, target.y + r);
    ctx.quadraticCurveTo(target.x, target.y, target.x + r, target.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    const healthRatio = target.health / 100;
    ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
    ctx.fillRect(target.x + 6, target.y + target.height + 10, (target.width - 12) * healthRatio, 6);
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.45)';
    ctx.strokeRect(target.x + 6, target.y + target.height + 10, target.width - 12, 6);
    ctx.restore();
  }

  function drawCrosshair() {
    ctx.save();
    ctx.translate(input.mouseX, input.mouseY);
    ctx.strokeStyle = 'rgba(248, 250, 252, 0.9)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.moveTo(-16, 0);
    ctx.lineTo(-4, 0);
    ctx.moveTo(4, 0);
    ctx.lineTo(16, 0);
    ctx.moveTo(0, -16);
    ctx.lineTo(0, -4);
    ctx.moveTo(0, 4);
    ctx.lineTo(0, 16);
    ctx.stroke();
    ctx.restore();
  }

  function drawSky() {
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#111827');
    gradient.addColorStop(1, '#0b1120');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'rgba(148, 163, 184, 0.3)';
    for (let i = 0; i < 6; i += 1) {
      const x = (i * 160 + performance.now() * 0.01) % (canvas.width + 200) - 100;
      ctx.beginPath();
      ctx.ellipse(x, 140 + Math.sin(x * 0.02) * 24, 120, 28, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawUIOverlay() {
    ctx.fillStyle = 'rgba(148, 163, 184, 0.25)';
    ctx.fillRect(24, 24, 220, 70);
    ctx.fillStyle = '#f8fafc';
    ctx.font = '16px "Poppins", sans-serif';
    ctx.fillText(`Altitude: ${Math.max(0, Math.round(groundHeight(player.x) - player.y))} m`, 36, 48);
    ctx.fillText(`Speed: ${Math.abs(player.vx).toFixed(1)} m/s`, 36, 70);
  }

  function loop() {
    drawSky();
    drawTerrain();
    updatePlayer();
    fireWeapon();
    updateProjectiles();
    updateTarget();
    cleanupProjectiles();
    drawProjectiles();
    drawTarget();
    drawPlayer();
    drawCrosshair();
    drawUIOverlay();
    requestAnimationFrame(loop);
  }

  weaponName.textContent = weapons[player.weaponIndex].name;
  loop();
  </script>
</body>
</html>
