<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stellar Drift - Endless Flight</title>
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <script src="gun-init.js"></script>
  <script src="score.js"></script>
  <link rel="stylesheet" href="styles/global.css">
  <style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: 'Poppins', sans-serif;
    background: radial-gradient(circle at top, #0a1630, #02040a 65%);
    color: #f1f5f9;
  }

  :root {
    --safe-top: calc(env(safe-area-inset-top, 0px) + 1rem);
    --safe-bottom: calc(env(safe-area-inset-bottom, 0px) + 1.5rem);
    --safe-left: calc(env(safe-area-inset-left, 0px) + 1.5rem);
    --safe-right: calc(env(safe-area-inset-right, 0px) + 1.5rem);
    --control-safe-zone: 0px;
  }

  body.touch-enabled {
    --control-safe-zone: 18rem;
  }

  canvas {
    position: fixed;
    inset: 0;
    display: block;
    touch-action: none;
    width: 100vw;
    height: 100vh;
    z-index: 1;
  }

  .overlay {
    position: fixed;
    top: calc(6.5rem + env(safe-area-inset-top, 0px));
    left: 50%;
    transform: translateX(-50%);
    width: min(440px, calc(100% - 2rem));
    background: rgba(15, 23, 42, 0.72);
    backdrop-filter: blur(12px);
    border-radius: 18px;
    border: 1px solid rgba(148, 163, 184, 0.45);
    box-shadow: 0 24px 60px rgba(15, 23, 42, 0.55);
    padding: 1.5rem 1.5rem 1.25rem;
    z-index: 10;
    transition: opacity 0.35s ease, transform 0.35s ease;
  }

  .overlay h1 {
    margin: 0;
    font-size: 1.75rem;
    letter-spacing: 0.04em;
  }

  .overlay p {
    margin: 0.65rem 0 0;
    font-size: 0.95rem;
    line-height: 1.6;
    color: rgba(226, 232, 240, 0.82);
  }

  .overlay-close {
    position: absolute;
    top: 0.8rem;
    right: 0.9rem;
    background: rgba(30, 41, 59, 0.65);
    border: 1px solid rgba(148, 163, 184, 0.45);
    color: rgba(226, 232, 240, 0.9);
    border-radius: 999px;
    padding: 0.25rem 0.75rem;
    font-size: 0.8rem;
    letter-spacing: 0.12em;
    cursor: pointer;
    text-transform: uppercase;
    transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
  }

  .overlay-close:focus-visible,
  .overlay-close:hover {
    background: rgba(59, 130, 246, 0.25);
    border-color: rgba(96, 165, 250, 0.55);
    color: #e0f2fe;
  }

  .overlay-hidden {
    opacity: 0;
    transform: translate(-50%, -18px);
    pointer-events: none;
  }

  .overlay-hidden .hint,
  .overlay-hidden p,
  .overlay-hidden h1 {
    pointer-events: none;
  }

  .overlay-toggle {
    position: fixed;
    top: calc(6rem + env(safe-area-inset-top, 0px));
    left: 50%;
    transform: translateX(-50%);
    padding: 0.55rem 1.15rem;
    border-radius: 999px;
    border: 1px solid rgba(96, 165, 250, 0.5);
    background: rgba(15, 23, 42, 0.72);
    color: rgba(191, 219, 254, 0.95);
    font-size: 0.82rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    box-shadow: 0 16px 32px rgba(15, 23, 42, 0.5);
    cursor: pointer;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease, transform 0.3s ease;
    z-index: 9;
  }

  .overlay-toggle:focus-visible,
  .overlay-toggle:hover {
    background: rgba(30, 41, 59, 0.8);
    color: #e0f2fe;
    border-color: rgba(96, 165, 250, 0.75);
  }

  .overlay-toggle-visible {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(0);
  }

  .status {
    position: fixed;
    top: calc(var(--safe-top) + 0.5rem);
    right: var(--safe-right);
    padding: 0.85rem 1.2rem;
    background: rgba(8, 25, 44, 0.7);
    border-radius: 14px;
    border: 1px solid rgba(94, 234, 212, 0.35);
    font-size: 0.9rem;
    letter-spacing: 0.08em;
    color: rgba(165, 243, 252, 0.92);
    box-shadow: 0 18px 40px rgba(8, 145, 178, 0.35);
    text-transform: uppercase;
    z-index: 11;
  }

  .status span {
    font-weight: 600;
    letter-spacing: 0.02em;
    color: #f0fdfc;
  }

  .score-panel {
    position: fixed;
    top: calc(var(--safe-top) + 3.45rem);
    right: var(--safe-right);
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
    padding: 0.85rem 1.1rem;
    background: rgba(8, 25, 44, 0.74);
    border-radius: 16px;
    border: 1px solid rgba(94, 234, 212, 0.38);
    box-shadow: 0 18px 42px rgba(8, 145, 178, 0.38);
    color: rgba(191, 219, 254, 0.92);
    z-index: 11;
    min-width: 196px;
  }

  .score-panel-title {
    font-size: 0.72rem;
    letter-spacing: 0.22em;
    text-transform: uppercase;
    color: rgba(165, 243, 252, 0.88);
  }

  .score-panel-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 1rem;
  }

  .score-row-label {
    font-size: 0.72rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.78);
  }

  .score-row-value {
    font-size: 0.95rem;
    font-weight: 500;
    letter-spacing: 0.04em;
    color: #e0f2fe;
  }

  .score-panel-row-total .score-row-value {
    font-size: 1.4rem;
    font-weight: 600;
    letter-spacing: 0.08em;
    color: #f0fdfc;
  }

  .score-indicator {
    position: fixed;
    top: calc(var(--safe-top) + 6.6rem);
    right: var(--safe-right);
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.15rem;
    padding: 0.75rem 1.15rem 0.85rem;
    background: rgba(8, 25, 44, 0.82);
    border-radius: 16px;
    border: 1px solid rgba(94, 234, 212, 0.45);
    box-shadow: 0 20px 54px rgba(8, 145, 178, 0.42);
    opacity: 0;
    transform: translateY(-8px);
    transition: opacity 0.3s ease, transform 0.3s ease;
    pointer-events: none;
    z-index: 12;
  }

  .score-indicator-visible {
    opacity: 1;
    transform: translateY(0);
  }

  .score-indicator .score-context {
    font-size: 0.78rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: rgba(125, 211, 252, 0.8);
  }

  .score-indicator .score-amount {
    font-size: 1.45rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    color: rgba(52, 211, 153, 0.95);
  }

  .score-indicator .score-unit {
    font-size: 0.75rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    color: rgba(165, 243, 252, 0.88);
  }

  .webgl-fallback {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2.5rem;
    text-align: center;
    background: radial-gradient(circle at top, #111827, #020617 60%);
    color: #e2e8f0;
    z-index: 999;
  }

  .webgl-fallback p {
    max-width: 520px;
    margin: 0;
    font-size: 1rem;
    line-height: 1.7;
  }

  .webgl-fallback strong {
    display: block;
    font-size: 1.25rem;
    margin-bottom: 1rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #f8fafc;
  }

  .mission-status {
    position: fixed;
    top: calc(var(--safe-top) + 4.25rem);
    left: var(--safe-left);
    padding: 0.85rem 1.1rem 0.95rem;
    max-width: min(360px, calc(100% - 2.75rem));
    background: rgba(8, 25, 44, 0.72);
    border-radius: 16px;
    border: 1px solid rgba(94, 234, 212, 0.35);
    color: rgba(191, 219, 254, 0.9);
    box-shadow: 0 22px 48px rgba(8, 145, 178, 0.38);
    letter-spacing: 0.04em;
    z-index: 11;
    transition: border-color 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease;
  }

  .mission-status span {
    display: block;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    color: rgba(165, 243, 252, 0.9);
    margin-bottom: 0.25rem;
  }

  .mission-status strong {
    display: block;
    font-size: 1.05rem;
    letter-spacing: 0.1em;
    color: #f0fdfc;
  }

  .mission-status .mission-tip {
    margin: 0.5rem 0 0;
    font-size: 0.82rem;
    line-height: 1.5;
    color: rgba(148, 163, 184, 0.92);
  }

  .mission-status-complete {
    border-color: rgba(52, 211, 153, 0.65);
    box-shadow: 0 26px 54px rgba(52, 211, 153, 0.35);
    transform: translate3d(0, -4px, 0);
  }

  .target-compass {
    position: fixed;
    top: calc(var(--safe-top) + 0.45rem);
    left: 50%;
    transform: translateX(-50%);
    width: min(520px, 92vw);
    height: 2.4rem;
    pointer-events: none;
    z-index: 12;
  }

  .target-compass::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100%;
    height: 1px;
    transform: translate(-50%, -50%);
    background: linear-gradient(
      to right,
      rgba(var(--compass-highlight-rgb, 56, 189, 248), 0),
      rgba(var(--compass-highlight-rgb, 56, 189, 248), 0.45),
      rgba(var(--compass-highlight-rgb, 56, 189, 248), 0)
    );
    opacity: 0.65;
  }

  .target-compass-dot {
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 0.65rem;
    height: 0.65rem;
    border-radius: 50%;
    background: rgba(148, 163, 184, 0.45);
    box-shadow:
      0 0 0 1px rgba(148, 163, 184, 0.4),
      0 0 12px rgba(59, 130, 246, 0.35);
    transition: transform 0.2s ease, opacity 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    opacity: 0.55;
  }

  .target-compass-dot.is-primary {
    background: rgba(var(--dot-highlight-rgb, 250, 204, 21), 0.9);
    box-shadow:
      0 0 0 1px rgba(var(--dot-highlight-rgb, 250, 204, 21), 0.8),
      0 0 22px rgba(var(--dot-highlight-rgb, 250, 204, 21), 0.6);
    transform: translate(-50%, -50%) scale(1.45);
    opacity: 0.95;
  }

  .target-compass-dot.is-complete {
    background: rgba(148, 163, 184, 0.2);
    box-shadow:
      0 0 0 1px rgba(148, 163, 184, 0.25),
      0 0 10px rgba(45, 212, 191, 0.25);
    opacity: 0.28;
  }

  .target-compass-dot.is-behind {
    background: rgba(var(--dot-highlight-rgb, 59, 130, 246), 0.35);
    box-shadow:
      0 0 0 1px rgba(var(--dot-highlight-rgb, 59, 130, 246), 0.45),
      0 0 12px rgba(var(--dot-highlight-rgb, 59, 130, 246), 0.4);
    opacity: 0.42;
  }

  .target-compass-dot.is-offscreen {
    opacity: 0.35;
    transform: translate(-50%, -50%) scale(0.85);
  }

  .top-buttons {
    position: fixed;
    top: var(--safe-top);
    left: 50%;
    transform: translateX(-50%);
    z-index: 12;
    display: flex;
    gap: 0.75rem;
  }

  .top-buttons a {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.3rem 0.8rem;
    border-radius: 999px;
    background: rgba(15, 23, 42, 0.65);
    border: 1px solid rgba(148, 163, 184, 0.35);
    color: rgba(226, 232, 240, 0.92);
    text-decoration: none;
    font-size: 0.78rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    box-shadow: 0 12px 30px rgba(15, 23, 42, 0.4);
    transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
  }

  .top-buttons a:hover,
  .top-buttons a:focus-visible {
    background: rgba(30, 41, 59, 0.78);
    border-color: rgba(96, 165, 250, 0.45);
    color: #e0f2fe;
  }

  .hint {
    margin-top: 1rem;
    padding: 0.75rem 1rem;
    border-radius: 14px;
    border: 1px solid rgba(148, 163, 184, 0.25);
    background: rgba(30, 41, 59, 0.6);
    font-size: 0.9rem;
    color: rgba(226, 232, 240, 0.75);
  }

  .control-toggle {
    position: fixed;
    top: calc(var(--safe-top) + 0.25rem);
    right: var(--safe-right);
    padding: 0.55rem 1.1rem;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.4);
    background: rgba(15, 23, 42, 0.7);
    color: rgba(226, 232, 240, 0.88);
    font-size: 0.82rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    box-shadow: 0 16px 32px rgba(15, 23, 42, 0.5);
    cursor: pointer;
    z-index: 13;
    transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
  }

  .control-toggle:hover,
  .control-toggle:focus-visible {
    background: rgba(30, 41, 59, 0.82);
    border-color: rgba(96, 165, 250, 0.5);
    color: rgba(226, 232, 240, 0.98);
  }

  .touch-ui {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 20;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }

  body.touch-enabled .touch-ui {
    opacity: 1;
    visibility: visible;
  }

  .touch-ui > * {
    pointer-events: auto;
  }

  .touch-gesture-hint {
    position: absolute;
    top: calc(6.75rem + env(safe-area-inset-top, 0px));
    right: var(--safe-right);
    padding: 0.6rem 1rem;
    border-radius: 14px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(15, 23, 42, 0.65);
    color: rgba(191, 219, 254, 0.88);
    font-size: 0.78rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    box-shadow: 0 16px 30px rgba(15, 23, 42, 0.45);
    pointer-events: none;
    transition: opacity 0.25s ease, transform 0.25s ease;
  }

  .touch-gesture-hint-hidden {
    opacity: 0;
    transform: translate3d(0, -8px, 0);
  }

  .touch-throttle {
    position: absolute;
    bottom: calc(2.5rem + env(safe-area-inset-bottom, 0px));
    right: var(--safe-right);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.85rem;
    touch-action: none;
  }

  .throttle-track {
    position: relative;
    width: 86px;
    height: 260px;
    border-radius: 42px;
    border: 1px solid rgba(148, 163, 184, 0.38);
    background: linear-gradient(180deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.85));
    box-shadow: inset 0 12px 24px rgba(15, 23, 42, 0.65);
    overflow: hidden;
  }

  .throttle-level {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 0;
    background: linear-gradient(180deg, rgba(59, 130, 246, 0.75), rgba(56, 189, 248, 0.2));
    border-bottom: 1px solid rgba(96, 165, 250, 0.45);
    transition: height 0.12s ease;
    z-index: 1;
  }

  .throttle-reverse {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 0;
    background: linear-gradient(180deg, rgba(248, 113, 113, 0.45), rgba(248, 113, 113, 0.18));
    border-top: 1px solid rgba(248, 113, 113, 0.4);
    transition: height 0.12s ease;
    z-index: 1;
  }

  .throttle-thumb {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 66px;
    height: 66px;
    border-radius: 50%;
    border: 1px solid rgba(59, 130, 246, 0.45);
    background: radial-gradient(circle, rgba(59, 130, 246, 0.75), rgba(30, 64, 175, 0.3));
    box-shadow: 0 14px 30px rgba(37, 99, 235, 0.45);
    transform: translate(-50%, -50%);
    transition: transform 0.06s ease;
    z-index: 2;
  }

  .throttle-scale {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.2rem;
    font-size: 0.7rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.75);
  }

  .touch-actions {
    position: absolute;
    bottom: 2.5rem;
    right: calc(var(--safe-right) + 86px + 1.25rem);
    display: grid;
    grid-template-columns: repeat(2, minmax(82px, 1fr));
    gap: 0.6rem;
  }

  .touch-action {
    padding: 0.65rem 0.75rem;
    border-radius: 14px;
    border: 1px solid rgba(94, 234, 212, 0.4);
    background: rgba(15, 23, 42, 0.65);
    color: rgba(165, 243, 252, 0.9);
    font-size: 0.8rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    box-shadow: 0 18px 32px rgba(13, 148, 136, 0.35);
    transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.12s ease;
  }

  .touch-action:active,
  .touch-action[aria-pressed="true"] {
    background: rgba(45, 212, 191, 0.35);
    border-color: rgba(94, 234, 212, 0.75);
    color: #0f172a;
    transform: translateY(1px);
  }

  .touch-action.wide {
    grid-column: span 2;
  }

  body.touch-enabled .hud {
    left: var(--safe-left);
    right: auto;
    transform: none;
  }

  body.touch-enabled .status {
    left: var(--safe-left);
    right: auto;
    transform: none;
    top: auto;
    bottom: calc(var(--safe-bottom) + var(--control-safe-zone));
  }

  @media (max-width: 900px) {
    .touch-gesture-hint {
      top: auto;
      bottom: 16rem;
      right: calc(env(safe-area-inset-right, 0px) + 1rem);
    }

    .touch-throttle {
      bottom: 2rem;
      right: calc(env(safe-area-inset-right, 0px) + 1rem);
    }

    .throttle-track {
      width: 72px;
      height: 220px;
    }

    .throttle-thumb {
      width: 58px;
      height: 58px;
    }

    .touch-actions {
      right: calc(1rem + 72px + 1rem);
      gap: 0.5rem;
    }

    .touch-action {
      font-size: 0.76rem;
    }

    .mission-status {
      left: 50%;
      transform: translateX(-50%);
      max-width: min(420px, calc(100% - 2rem));
    }

    .target-compass {
      top: calc(var(--safe-top) + 0.25rem);
      width: min(460px, 94vw);
    }
  }

  @media (max-width: 640px) {
    .touch-actions {
      right: calc(env(safe-area-inset-right, 0px) + 1rem);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 2rem + 220px + 1.5rem);
      grid-template-columns: minmax(150px, 1fr);
    }

    .touch-action.wide {
      grid-column: span 1;
    }

    body.touch-enabled .status {
      bottom: calc(env(safe-area-inset-bottom, 0px) + 2rem + 220px + 8rem);
    }

    .mission-status {
      top: calc(var(--safe-top) + 5.25rem);
      left: 50%;
      transform: translateX(-50%);
      max-width: min(360px, 90vw);
    }

    .target-compass {
      top: calc(var(--safe-top) + 0.2rem);
      height: 2.2rem;
    }
  }

  .hud {
    position: fixed;
    bottom: calc(var(--safe-bottom) + var(--control-safe-zone));
    left: var(--safe-left);
    padding: 1rem 1.2rem;
    background: rgba(8, 25, 44, 0.7);
    border-radius: 16px;
    border: 1px solid rgba(148, 163, 184, 0.32);
    box-shadow: 0 20px 40px rgba(15, 23, 42, 0.45);
    color: rgba(226, 232, 240, 0.85);
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    z-index: 11;
  }

  .hud-gauge + .hud-gauge {
    margin-top: 0.75rem;
  }

  .hud-gauge span {
    display: block;
    margin-bottom: 0.45rem;
    font-size: 0.75rem;
    letter-spacing: 0.16em;
    color: rgba(148, 163, 184, 0.95);
  }

  .hud-meter {
    width: 200px;
    height: 6px;
    background: rgba(15, 23, 42, 0.75);
    border-radius: 999px;
    overflow: hidden;
    border: 1px solid rgba(71, 85, 105, 0.6);
  }

  .hud-meter-fill {
    height: 100%;
    transform-origin: left center;
    transform: scaleX(0.08);
    background: linear-gradient(90deg, rgba(56, 189, 248, 0.4), rgba(34, 211, 238, 0.9));
    box-shadow: 0 0 14px rgba(34, 211, 238, 0.5);
  }

  .reticle {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 44px;
    height: 44px;
    pointer-events: none;
    z-index: 40;
  }

  .reticle-ring {
    width: 100%;
    height: 100%;
    border: 1px solid rgba(94, 234, 212, 0.35);
    border-radius: 50%;
    box-shadow: 0 0 18px rgba(20, 184, 166, 0.4);
  }

  .reticle-dot {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: rgba(56, 189, 248, 0.85);
    transform: translate(-50%, -50%);
    box-shadow: 0 0 16px rgba(14, 165, 233, 0.8);
  }

  @media (max-width: 720px) {
    .overlay {
      top: 7.5rem;
      padding: 1rem;
    }

    .overlay-toggle {
      top: 7rem;
    }

    .overlay h1 {
      font-size: 1.35rem;
    }

    .overlay p {
      font-size: 0.85rem;
    }

    .status {
      left: 50%;
      right: auto;
      transform: translateX(-50%);
      top: auto;
      bottom: 1rem;
    }

    .score-panel {
      top: auto;
      right: auto;
      left: 50%;
      transform: translate(-50%, 0);
      bottom: calc(var(--safe-bottom) + var(--control-safe-zone) + 8.5rem);
      min-width: min(260px, 90vw);
      align-items: stretch;
      padding: 0.75rem 1rem;
      text-align: center;
    }

    .score-panel-row {
      justify-content: space-between;
    }

    .score-panel-row-total .score-row-value {
      font-size: 1.28rem;
    }

    .score-indicator {
      top: auto;
      bottom: calc(var(--safe-bottom) + var(--control-safe-zone) + 6rem);
      left: 50%;
      right: auto;
      transform: translate(-50%, -8px);
      align-items: center;
    }

    .score-indicator-visible {
      transform: translate(-50%, 0);
    }

    .hud {
      left: 50%;
      transform: translateX(-50%);
      bottom: 4.5rem;
    }

    .hud-meter {
      width: min(200px, 64vw);
    }
  }

  @media (max-width: 540px) {
    .overlay {
      top: calc(5.5rem + env(safe-area-inset-top, 0px));
      width: min(360px, calc(100% - 1.25rem));
      padding: 0.85rem 0.9rem 0.85rem;
    }

    .overlay h1 {
      font-size: 1.2rem;
      letter-spacing: 0.06em;
    }

    .overlay p,
    .hint {
      font-size: 0.78rem;
      line-height: 1.55;
    }

    .overlay-toggle {
      top: auto;
      bottom: calc(var(--safe-bottom) + var(--control-safe-zone) + 0.75rem);
      transform: translate(-50%, 0);
    }

    .status {
      top: calc(var(--safe-top) + 0.25rem);
      right: var(--safe-right);
      left: auto;
      bottom: auto;
      transform: none;
      font-size: 0.78rem;
      padding: 0.75rem 1rem;
    }

    body.touch-enabled .status {
      left: auto;
      right: var(--safe-right);
      top: calc(var(--safe-top) + 0.25rem);
      bottom: auto;
    }

    .score-panel {
      left: var(--safe-left);
      right: var(--safe-right);
      transform: none;
      bottom: calc(var(--safe-bottom) + var(--control-safe-zone) + 8.75rem);
      min-width: auto;
      width: calc(100% - var(--safe-left) - var(--safe-right));
      max-width: 320px;
      margin: 0 auto;
    }

    .score-panel-row-total .score-row-value {
      font-size: 1.22rem;
    }

    .score-indicator {
      bottom: calc(var(--safe-bottom) + var(--control-safe-zone) + 6.5rem);
      left: 50%;
      right: auto;
      transform: translate(-50%, -8px);
      padding: 0.7rem 1rem 0.8rem;
    }

    .score-indicator-visible {
      transform: translate(-50%, 0);
    }

    .hud {
      left: var(--safe-left);
      transform: none;
      bottom: calc(var(--safe-bottom) + var(--control-safe-zone));
      width: min(240px, 78vw);
      padding: 0.85rem 1rem;
      font-size: 0.78rem;
    }

    .hud-gauge span {
      font-size: 0.68rem;
      letter-spacing: 0.14em;
    }

    .hud-meter {
      width: min(180px, 70vw);
    }

    .top-buttons {
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .top-buttons a {
      width: min(220px, 90vw);
    }

    .control-toggle {
      top: calc(var(--safe-top) + 2.75rem);
      right: var(--safe-right);
      font-size: 0.75rem;
    }

    .touch-gesture-hint {
      top: calc(5.5rem + env(safe-area-inset-top, 0px));
      right: var(--safe-right);
      font-size: 0.72rem;
    }

    .touch-actions {
      bottom: calc(var(--safe-bottom) + 220px + 1.5rem);
    }

    .mission-status {
      top: calc(var(--safe-top) + 5rem);
      max-width: min(320px, 88vw);
      padding: 0.75rem 0.9rem 0.85rem;
    }
  }
  </style>
</head>
<body class="theme-dark">
  <div class="top-buttons">
    <a href="games.html">üéÆ Back to Hub</a>
    <a href="index.html">üè† Portal</a>
  </div>

  <button
    class="control-toggle"
    id="controlModeToggle"
    type="button"
    aria-pressed="false"
    aria-label="Toggle touch controls"
  >
    Touch Controls: Off
  </button>

  <button class="overlay-toggle" id="overlayToggle" type="button" aria-hidden="true">Show Flight Controls</button>

  <div class="overlay" aria-live="polite" aria-hidden="false">
    <button class="overlay-close" id="overlayClose" type="button">Hide</button>
    <h1>Stellar Drift</h1>
    <p id="primaryInstructions">
      Glide through procedurally scattered stars and luminous worlds. Click anywhere to engage flight controls,
      then use your mouse to look and <strong>WASD</strong> to steer. Hold <strong>Shift</strong> to boost and left-click or
      press <strong>F</strong> to fire a laser burst.
    </p>
    <div class="hint" id="secondaryInstructions">
      Press <strong>R</strong> if you ever want to re-center your ship. Pointer lock keeps the cursor inside the
      cockpit‚Äîpress <strong>Esc</strong> to release. Tag the luminous mission beacons in any order and follow the pulsing
      canopy compass to line up your next objective.
    </div>
  </div>

  <div class="touch-ui" id="touchUI" aria-hidden="true">
    <div class="touch-gesture-hint" aria-hidden="true">Swipe anywhere to steer</div>
    <div
      class="touch-throttle"
      id="throttleControl"
      role="slider"
      aria-label="Throttle control"
      aria-valuemin="-100"
      aria-valuemax="100"
      aria-valuenow="0"
      aria-orientation="vertical"
    >
      <div class="throttle-track" id="throttleTrack">
        <div class="throttle-level" id="throttleLevel" aria-hidden="true"></div>
        <div class="throttle-reverse" id="throttleReverse" aria-hidden="true"></div>
        <div class="throttle-thumb" id="throttleThumb" aria-hidden="true"></div>
      </div>
      <div class="throttle-scale" aria-hidden="true">
        <span>Boost</span>
        <span>Idle</span>
        <span>Reverse</span>
      </div>
    </div>
    <div class="touch-actions" role="group" aria-label="Flight quick actions">
      <button class="touch-action" type="button" data-action="boost" aria-pressed="false">Boost</button>
      <button class="touch-action" type="button" data-action="fire" aria-pressed="false">Fire üîÜ</button>
      <button class="touch-action" type="button" data-action="pause" aria-pressed="false">Pause</button>
      <button class="touch-action" type="button" data-action="ascend" aria-pressed="false">Ascend</button>
      <button class="touch-action" type="button" data-action="descend" aria-pressed="false">Descend</button>
      <button class="touch-action" type="button" data-action="strafe-left" aria-pressed="false">Strafe ‚óÄ</button>
      <button class="touch-action" type="button" data-action="strafe-right" aria-pressed="false">Strafe ‚ñ∂</button>
      <button class="touch-action wide" type="button" data-action="recenter">Re-center</button>
    </div>
  </div>

  <div class="hud" aria-hidden="true">
    <div class="hud-gauge">
      <span>Velocity</span>
      <div class="hud-meter"><div class="hud-meter-fill" id="speedBar"></div></div>
    </div>
    <div class="hud-gauge">
      <span>Stability</span>
      <div class="hud-meter"><div class="hud-meter-fill" id="stabilityBar"></div></div>
    </div>
  </div>

  <div class="mission-status" id="missionStatus" role="status" aria-live="polite">
    <span>Mission Tracker</span>
    <strong id="objectiveCounter">0/5 sector ¬∑ 0 total</strong>
    <p class="mission-tip" id="missionTip">
      Tag the luminous beacons with a laser burst to harmonize this sector. Finish them in any order‚Äîthe brightest pulse is a
      suggested lead.
    </p>
  </div>

  <div class="status" id="status"></div>

  <div
    class="score-panel"
    id="scorePanel"
    role="status"
    aria-live="polite"
    aria-atomic="true"
  >
    <span class="score-panel-title">Points</span>
    <div class="score-panel-row">
      <span class="score-row-label">Pilot</span>
      <span class="score-row-value" id="scorePanelUser">Explorer</span>
    </div>
    <div class="score-panel-row score-panel-row-total">
      <span class="score-row-label">Total</span>
      <span class="score-row-value" id="scorePanelTotal">0</span>
    </div>
  </div>

  <div class="score-indicator" id="scoreIndicator" role="status" aria-live="polite"></div>

  <div class="target-compass" id="targetCompass" aria-hidden="true"></div>

  <div class="reticle" aria-hidden="true">
    <div class="reticle-ring"></div>
    <div class="reticle-dot"></div>
  </div>

  <script
    src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"
    integrity="sha384-FnJUTmxFMWfpLQrvHL2uy8VKoMnr2zmljCJ4RkoHfE+wBRHzYs1tJwGY+wzMezvD"
    crossorigin="anonymous"
  ></script>
  <script>
  function showWebGLFallback(message) {
    const fallback = document.createElement('div');
    fallback.className = 'webgl-fallback';
    fallback.innerHTML = `
      <p>
        <strong>WebGL Flight Systems Offline</strong>
        ${message || 'Your device or browser blocked the 3D renderer. Enable WebGL or update your graphics drivers to enter Stellar Drift.'}
      </p>
    `;
    document.body.appendChild(fallback);
  }

  function isWebGLSupported() {
    try {
      const testCanvas = document.createElement('canvas');
      return !!(
        window.WebGLRenderingContext &&
        (testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl'))
      );
    } catch (error) {
      return false;
    }
  }

  if (!isWebGLSupported()) {
    showWebGLFallback('This flight deck needs WebGL acceleration. Please enable it in your browser settings or switch to a compatible device.');
    throw new Error('WebGL not supported in this browser');
  }

  let renderer;
  try {
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  } catch (error) {
    console.error('Failed to initialize Stellar Drift renderer', error);
    showWebGLFallback('We could not initialize the 3D renderer. Updating your graphics drivers or toggling hardware acceleration usually resolves this.');
    throw new Error('WebGL renderer initialization failed');
  }

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x010312);
  scene.fog = new THREE.FogExp2(0x020618, 0.0016);

  const camera = new THREE.PerspectiveCamera(72, window.innerWidth / window.innerHeight, 0.2, 3000);
  camera.position.set(0, 0, 20);

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  const statusEl = document.getElementById('status');
  const speedBar = document.getElementById('speedBar');
  const stabilityBar = document.getElementById('stabilityBar');
  const overlay = document.querySelector('.overlay');
  const overlayClose = document.getElementById('overlayClose');
  const overlayToggle = document.getElementById('overlayToggle');
  const primaryInstructions = document.getElementById('primaryInstructions');
  const secondaryInstructions = document.getElementById('secondaryInstructions');
  const controlModeToggle = document.getElementById('controlModeToggle');
  const touchUI = document.getElementById('touchUI');
  const touchGestureHint = touchUI ? touchUI.querySelector('.touch-gesture-hint') : null;
  const throttleControl = document.getElementById('throttleControl');
  const throttleTrack = document.getElementById('throttleTrack');
  const throttleThumb = document.getElementById('throttleThumb');
  const throttleLevel = document.getElementById('throttleLevel');
  const throttleReverse = document.getElementById('throttleReverse');
  const missionStatus = document.getElementById('missionStatus');
  const objectiveCounter = document.getElementById('objectiveCounter');
  const missionTip = document.getElementById('missionTip');
  const targetCompass = document.getElementById('targetCompass');
  const scoreIndicator = document.getElementById('scoreIndicator');
  const scorePanelUser = document.getElementById('scorePanelUser');
  const scorePanelTotal = document.getElementById('scorePanelTotal');

  const sanitizeScoreValue = value => {
    if (window.ScoreSystem && typeof window.ScoreSystem.sanitizeScore === 'function') {
      return window.ScoreSystem.sanitizeScore(value);
    }
    const numeric = typeof value === 'number' ? value : Number(value);
    if (!Number.isFinite(numeric)) {
      return 0;
    }
    return Math.max(0, Math.round(numeric));
  };

  const aliasToDisplay = value => {
    const normalized = typeof value === 'string' ? value.trim() : '';
    if (!normalized) {
      return '';
    }
    return normalized.includes('@') ? normalized.split('@')[0] : normalized;
  };

  const computeScoreUserLabel = state => {
    if (!state || !state.mode || state.mode === 'anon') {
      return 'Explorer';
    }
    if (state.mode === 'user') {
      const storedName = (state.username || '').trim() || (localStorage.getItem('username') || '').trim();
      if (storedName) {
        return storedName;
      }
      const alias = (state.alias || '').trim() || (localStorage.getItem('alias') || '').trim();
      if (alias) {
        return aliasToDisplay(alias);
      }
      return 'Pilot';
    }
    if (state.mode === 'guest') {
      const guestDisplay = (state.guestDisplayName || '').trim() || (localStorage.getItem('guestDisplayName') || '').trim();
      if (guestDisplay) {
        return guestDisplay;
      }
      return 'Guest Pilot';
    }
    return 'Explorer';
  };

  const applyScorePanelUser = state => {
    if (!scorePanelUser) {
      return;
    }
    scorePanelUser.textContent = computeScoreUserLabel(state);
  };

  const updateScorePanelTotal = value => {
    if (!scorePanelTotal) {
      return;
    }
    const normalized = sanitizeScoreValue(value);
    scorePanelTotal.textContent = normalized.toLocaleString();
  };

  let activeScoreState = { mode: 'anon' };
  let fallbackScoreTally = 0;

  const refreshScorePanelState = stateOverride => {
    const resolved = stateOverride
      || (scoreManager && typeof scoreManager.getState === 'function'
        ? scoreManager.getState()
        : (window.ScoreSystem && typeof window.ScoreSystem.computeAuthState === 'function'
          ? window.ScoreSystem.computeAuthState()
          : { mode: 'anon' }));
    activeScoreState = resolved || { mode: 'anon' };
    applyScorePanelUser(activeScoreState);
    return activeScoreState;
  };

  const scoreboardNameKeys = new Set(['username', 'guestDisplayName', 'alias', 'signedIn', 'guest']);

  const gun = typeof Gun === 'function'
    ? Gun(window.__GUN_PEERS__ || [
        'wss://relay.3dvr.tech/gun',
        'wss://gun-relay-3dvr.fly.dev/gun'
      ])
    : null;
  const portalUser = gun && typeof gun.user === 'function' ? gun.user() : null;
  const portalRoot = gun && typeof gun.get === 'function' ? gun.get('3dvr-portal') : null;
  const scoreManager = window.ScoreSystem && typeof window.ScoreSystem.getManager === 'function' && gun
    ? window.ScoreSystem.getManager({ gun, user: portalUser, portalRoot })
    : null;

  if (window.ScoreSystem && typeof window.ScoreSystem.ensureGuestIdentity === 'function') {
    window.ScoreSystem.ensureGuestIdentity();
  }

  const initialScoreState = scoreManager && typeof scoreManager.getState === 'function'
    ? scoreManager.getState()
    : (window.ScoreSystem && typeof window.ScoreSystem.computeAuthState === 'function'
      ? window.ScoreSystem.computeAuthState()
      : null);

  activeScoreState = refreshScorePanelState(initialScoreState);

  if (scoreManager && typeof scoreManager.getCurrent === 'function') {
    fallbackScoreTally = sanitizeScoreValue(scoreManager.getCurrent());
  } else {
    fallbackScoreTally = sanitizeScoreValue(fallbackScoreTally);
  }
  updateScorePanelTotal(fallbackScoreTally);

  if (scoreManager && typeof scoreManager.subscribe === 'function') {
    scoreManager.subscribe(value => {
      fallbackScoreTally = sanitizeScoreValue(value);
      updateScorePanelTotal(fallbackScoreTally);
      refreshScorePanelState();
    });
    if (typeof scoreManager.whenReady === 'function') {
      scoreManager.whenReady()
        .then(value => {
          fallbackScoreTally = sanitizeScoreValue(value);
          updateScorePanelTotal(fallbackScoreTally);
          refreshScorePanelState();
        })
        .catch(() => {});
    }
  }

  if (typeof window !== 'undefined') {
    window.addEventListener('storage', event => {
      if (!event || !event.key) {
        return;
      }
      if (scoreboardNameKeys.has(event.key)) {
        refreshScorePanelState();
      }
    });
  }

  let scoreIndicatorHideTimeout = null;
  let scoreIndicatorClearTimeout = null;

  function showScoreIndicator(details) {
    if (!scoreIndicator || !details) {
      return;
    }
    if (scoreIndicatorHideTimeout) {
      window.clearTimeout(scoreIndicatorHideTimeout);
      scoreIndicatorHideTimeout = null;
    }
    if (scoreIndicatorClearTimeout) {
      window.clearTimeout(scoreIndicatorClearTimeout);
      scoreIndicatorClearTimeout = null;
    }
    scoreIndicator.innerHTML = '';

    if (details && typeof details === 'object' && !Array.isArray(details)) {
      const hasAmount = typeof details.amount !== 'undefined';
      const normalizedAmount = hasAmount ? sanitizeScoreValue(details.amount) : 0;
      const labelText = typeof details.label === 'string' ? details.label.trim() : '';
      const hasUnit = typeof details.unit === 'string' && details.unit.trim();
      const unitText = hasUnit ? details.unit.trim() : 'points';
      const extraText = typeof details.text === 'string' ? details.text.trim() : '';

      if (normalizedAmount > 0) {
        if (labelText) {
          const contextEl = document.createElement('span');
          contextEl.className = 'score-context';
          contextEl.textContent = labelText;
          scoreIndicator.appendChild(contextEl);
        }

        const amountEl = document.createElement('span');
        amountEl.className = 'score-amount';
        amountEl.textContent = `+${normalizedAmount.toLocaleString()}`;
        scoreIndicator.appendChild(amountEl);

        const unitEl = document.createElement('span');
        unitEl.className = 'score-unit';
        unitEl.textContent = unitText;
        scoreIndicator.appendChild(unitEl);

        if (extraText) {
          const textEl = document.createElement('span');
          textEl.className = 'score-unit';
          textEl.textContent = extraText;
          scoreIndicator.appendChild(textEl);
        }
      } else {
        const fallbackText = extraText || labelText;
        if (fallbackText) {
          scoreIndicator.textContent = fallbackText;
        }
      }
    } else {
      scoreIndicator.textContent = String(details);
    }

    scoreIndicator.classList.add('score-indicator-visible');
    scoreIndicatorHideTimeout = window.setTimeout(() => {
      scoreIndicator.classList.remove('score-indicator-visible');
      scoreIndicatorHideTimeout = null;
      scoreIndicatorClearTimeout = window.setTimeout(() => {
        scoreIndicator.innerHTML = '';
        scoreIndicatorClearTimeout = null;
      }, 320);
    }, 2200);
  }

  function awardScore(points, message) {
    const value = Number(points);
    if (Number.isFinite(value) && value > 0) {
      if (scoreManager && typeof scoreManager.increment === 'function') {
        scoreManager.increment(value);
      } else {
        fallbackScoreTally = Math.max(0, fallbackScoreTally + Math.round(value));
        updateScorePanelTotal(fallbackScoreTally);
      }
    }
    if (message) {
      showScoreIndicator(message);
    }
  }

  const ambient = new THREE.AmbientLight(0x7dd3fc, 0.38);
  scene.add(ambient);

  const keyLight = new THREE.DirectionalLight(0xfff7d6, 1.25);
  keyLight.position.set(120, 80, 40);
  scene.add(keyLight);

  const rimLight = new THREE.PointLight(0x60a5fa, 1.6, 420, 2);
  rimLight.position.set(-180, 30, -50);
  scene.add(rimLight);

  function createNebulae() {
    const nebulaMaterial = new THREE.MeshBasicMaterial({
      color: 0x22d3ee,
      transparent: true,
      opacity: 0.1,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const nebulae = [];
    for (let i = 0; i < 7; i++) {
      const nebulaGeometry = new THREE.IcosahedronGeometry(140 + Math.random() * 90, 2);
      const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial.clone());
      nebula.position.set((Math.random() - 0.5) * 1200, (Math.random() - 0.5) * 640, -220 - Math.random() * 1800);
      nebula.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      const hueShift = 0.5 + Math.random() * 0.2;
      nebula.material.color.setHSL(hueShift, 0.7, 0.6);
      nebula.material.opacity = 0.08 + Math.random() * 0.08;
      scene.add(nebula);
      nebulae.push({
        mesh: nebula,
        drift: new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 1.5, 6 + Math.random() * 12)
      });
    }
    return nebulae;
  }

  function createStarField({ count, spread, size, twinkle, rotationSpeed }) {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const color = new THREE.Color();

    for (let i = 0; i < count; i++) {
      const i3 = i * 3;
      positions[i3] = (Math.random() - 0.5) * spread.x;
      positions[i3 + 1] = (Math.random() - 0.5) * spread.y;
      positions[i3 + 2] = (Math.random() - 0.5) * spread.z;

      const hue = 0.55 + Math.random() * twinkle;
      color.setHSL(hue, 0.6 + Math.random() * 0.2, 0.7 + Math.random() * 0.2);
      colors[i3] = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size,
      vertexColors: true,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.95,
      depthWrite: false
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);
    return { points, rotationSpeed };
  }

  const nebulae = createNebulae();
  const starLayers = [
    createStarField({
      count: 1800,
      spread: new THREE.Vector3(2600, 1800, 2600),
      size: 1.6,
      twinkle: 0.14,
      rotationSpeed: 0.006
    }),
    createStarField({
      count: 1200,
      spread: new THREE.Vector3(1800, 1200, 1800),
      size: 2.1,
      twinkle: 0.18,
      rotationSpeed: 0.01
    }),
    createStarField({
      count: 800,
      spread: new THREE.Vector3(900, 720, 900),
      size: 2.6,
      twinkle: 0.22,
      rotationSpeed: 0.016
    })
  ];

  function createGlowTexture() {
    const size = 256;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const context = canvas.getContext('2d');
    const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
    gradient.addColorStop(0, 'rgba(56, 189, 248, 0.9)');
    gradient.addColorStop(0.35, 'rgba(56, 189, 248, 0.6)');
    gradient.addColorStop(1, 'rgba(56, 189, 248, 0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, size, size);
    return new THREE.CanvasTexture(canvas);
  }

  const anomalyTexture = createGlowTexture();
  const anomalies = [];
  for (let i = 0; i < 12; i++) {
    const spriteMaterial = new THREE.SpriteMaterial({
      map: anomalyTexture,
      color: new THREE.Color().setHSL(0.52 + Math.random() * 0.16, 0.8, 0.6),
      transparent: true,
      opacity: 0.45,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    const scale = 60 + Math.random() * 120;
    sprite.scale.set(scale, scale, scale);
    sprite.position.set((Math.random() - 0.5) * 1100, (Math.random() - 0.5) * 660, -300 - Math.random() * 2000);
    scene.add(sprite);
    anomalies.push({
      sprite,
      pulse: Math.random() * Math.PI * 2,
      baseOpacity: spriteMaterial.opacity,
      speed: 0.6 + Math.random() * 0.5
    });
  }

  function createPlanet(radius, color, position, emissive) {
    const geometry = new THREE.SphereGeometry(radius, 64, 64);
    const material = new THREE.MeshStandardMaterial({
      color,
      metalness: 0.2,
      roughness: 0.6,
      emissive: emissive || 0x000000,
      emissiveIntensity: emissive ? 0.4 : 0
    });
    const planet = new THREE.Mesh(geometry, material);
    planet.position.copy(position);
    planet.castShadow = false;
    planet.receiveShadow = false;
    scene.add(planet);
    return planet;
  }

  const planetPivots = [];
  const planetData = [
    {
      radius: 52,
      color: 0x2563eb,
      position: new THREE.Vector3(-200, -60, -620),
      emissive: 0x172554,
      ringColor: 0x7dd3fc
    },
    {
      radius: 34,
      color: 0xf97316,
      position: new THREE.Vector3(260, 70, -760),
      emissive: 0x7c2d12,
      ringColor: 0xfacc15
    },
    {
      radius: 20,
      color: 0x0ea5e9,
      position: new THREE.Vector3(-40, 120, -480),
      emissive: 0x0ea5e9,
      ringColor: 0x67e8f9
    },
    {
      radius: 28,
      color: 0x14b8a6,
      position: new THREE.Vector3(140, -110, -420),
      emissive: 0x14b8a6,
      ringColor: 0x99f6e4
    }
  ];

  const planets = planetData.map((planetInfo, index) => {
    const pivot = new THREE.Group();
    pivot.position.set(0, 0, -200 - index * 140);
    scene.add(pivot);
    const planet = createPlanet(planetInfo.radius, planetInfo.color, planetInfo.position.clone(), planetInfo.emissive);
    planet.position.sub(pivot.position);
    pivot.add(planet);

    const ringGeometry = new THREE.RingGeometry(planetInfo.radius * 1.18, planetInfo.radius * 1.48, 72);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: planetInfo.ringColor,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.28,
      blending: THREE.AdditiveBlending
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.copy(planet.position.clone());
    ring.rotation.x = Math.random() * 1.2;
    ring.rotation.y = Math.random() * 1.2;
    pivot.add(ring);
    planet.userData.ring = ring;

    planet.userData.orbitSpeed = 0.04 + index * 0.02;
    planet.userData.baseY = planet.position.y;
    planet.userData.floatPhase = Math.random() * Math.PI * 2;
    planet.userData.baseScale = planet.scale.x;
    planet.userData.baseEmissive = planet.material ? planet.material.emissiveIntensity || 0 : 0;
    // Widen the collision radius so laser shots register as soon as they graze the surface.
    const boundingRadius = planet.geometry?.boundingSphere?.radius || planetInfo.radius;
    planet.userData.hitRadius = Math.max(boundingRadius + 12, boundingRadius * 1.05, 18);
    planet.userData.hitElapsed = 0;
    planet.userData.hitDuration = 0;
    planetPivots.push(pivot);

    if (planet.userData.ring) {
      planet.userData.ring.userData = planet.userData.ring.userData || {};
      planet.userData.ring.userData.baseOpacity = planet.userData.ring.material.opacity;
      planet.userData.ring.userData.baseScale = planet.userData.ring.scale.x;
    }
    return planet;
  });

  const planetTargets = planets.map((planet) => ({
    planet,
    hitRadius: planet.userData.hitRadius,
    effectDuration: 1.4
  }));

  function registerPlanetHit(target) {
    if (!target || !target.planet) {
      return;
    }
    const planet = target.planet;
    planet.userData.hitElapsed = 0;
    planet.userData.hitDuration = target.effectDuration;
  }

  const objectiveGroup = new THREE.Group();
  scene.add(objectiveGroup);

  const objectiveConfigs = [
    {
      name: 'Azure Beacon',
      color: 0x38bdf8,
      basePosition: new THREE.Vector3(90, 48, -340)
    },
    {
      name: 'Solaris Relay',
      color: 0xfacc15,
      basePosition: new THREE.Vector3(-160, 26, -520)
    },
    {
      name: 'Verdant Spire',
      color: 0x34d399,
      basePosition: new THREE.Vector3(140, -42, -640)
    },
    {
      name: 'Crimson Chime',
      color: 0xf87171,
      basePosition: new THREE.Vector3(-60, 70, -780)
    },
    {
      name: 'Umbral Node',
      color: 0xa855f7,
      basePosition: new THREE.Vector3(60, -28, -920)
    }
  ];

  function randomizeObjectivePosition(base) {
    return base
      .clone()
      .add(new THREE.Vector3((Math.random() - 0.5) * 120, (Math.random() - 0.5) * 80, (Math.random() - 0.5) * 160));
  }

  function createObjectiveMarker(config) {
    const group = new THREE.Group();
    group.position.copy(randomizeObjectivePosition(config.basePosition));

    const coreMaterial = new THREE.MeshStandardMaterial({
      color: config.color,
      emissive: config.color,
      emissiveIntensity: 0.9,
      roughness: 0.25,
      metalness: 0.1,
      transparent: true,
      opacity: 0.92
    });
    const core = new THREE.Mesh(new THREE.SphereGeometry(4.2, 48, 48), coreMaterial);
    group.add(core);

    const ringMaterial = new THREE.MeshBasicMaterial({
      color: config.color,
      transparent: true,
      opacity: 0.36,
      blending: THREE.AdditiveBlending
    });
    const ring = new THREE.Mesh(new THREE.TorusGeometry(8.2, 0.55, 28, 96), ringMaterial);
    ring.rotation.x = Math.PI / 2;
    group.add(ring);

    const pylonMaterial = new THREE.MeshBasicMaterial({
      color: config.color,
      transparent: true,
      opacity: 0.32,
      blending: THREE.AdditiveBlending
    });
    const pylon = new THREE.Mesh(new THREE.CylinderGeometry(0.48, 0.48, 26, 24, 1, true), pylonMaterial);
    pylon.position.y = 15;
    pylon.visible = false;
    group.add(pylon);

    const glowMaterial = new THREE.SpriteMaterial({
      map: anomalyTexture,
      color: new THREE.Color(config.color),
      transparent: true,
      opacity: 0.42,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const glow = new THREE.Sprite(glowMaterial);
    glow.scale.set(26, 26, 26);
    group.add(glow);

    objectiveGroup.add(group);

    return {
      name: config.name,
      color: config.color,
      basePosition: config.basePosition.clone(),
      group,
      core,
      ring,
      pylon,
      glow,
      completed: false,
      pulse: Math.random() * Math.PI * 2,
      hitRadius: 11
    };
  }

  const objectiveMarkers = objectiveConfigs.map((config) => createObjectiveMarker(config));
  let primaryObjective = null;
  let totalSyncedObjectives = 0;

  const compassDots = targetCompass
    ? objectiveMarkers.map((marker) => {
        const dot = document.createElement('span');
        dot.className = 'target-compass-dot';
        dot.setAttribute('aria-hidden', 'true');
        targetCompass.appendChild(dot);
        return { marker, dot };
      })
    : [];

  const compassVectors = {
    ndc: new THREE.Vector3(),
    world: new THREE.Vector3(),
    direction: new THREE.Vector3(),
    forward: new THREE.Vector3()
  };

  const compassHighlightColor = new THREE.Color();

  function formatRgbComponents(hexColor) {
    compassHighlightColor.setHex(hexColor);
    if (typeof compassHighlightColor.convertLinearToSRGB === 'function') {
      compassHighlightColor.convertLinearToSRGB();
    }
    const r = Math.round(compassHighlightColor.r * 255);
    const g = Math.round(compassHighlightColor.g * 255);
    const b = Math.round(compassHighlightColor.b * 255);
    return `${r}, ${g}, ${b}`;
  }

  function updateObjectiveUI() {
    if (!objectiveCounter) {
      return;
    }
    const remaining = objectiveMarkers.filter((marker) => !marker.completed).length;
    const syncedThisPass = objectiveMarkers.length - remaining;
    const nextMarker = objectiveMarkers.find((marker) => !marker.completed) || null;
    objectiveCounter.textContent = `${syncedThisPass}/${objectiveMarkers.length} sector ¬∑ ${totalSyncedObjectives} total`;
    primaryObjective = nextMarker;
    objectiveMarkers.forEach((marker) => {
      const isPrimary = !marker.completed && marker === primaryObjective;
      marker.pylon.visible = isPrimary;
      if (!isPrimary) {
        marker.pylon.material.opacity = 0;
      }
    });
    if (missionTip) {
      if (remaining === 0) {
        primaryObjective = null;
        missionTip.textContent = 'Sector clear! New resonance points incoming‚Äîstand by.';
      } else {
        missionTip.textContent = nextMarker
          ? `Tag ${nextMarker.name} with a laser burst to sync its signal. The canopy compass will keep it centered while other beacons wait their turn.`
          : 'Tag the luminous mission beacons to sync their signals.';
      }
    }
    updateCompass();
  }

  updateObjectiveUI();

  function highlightMissionStatus() {
    if (!missionStatus) {
      return;
    }
    missionStatus.classList.add('mission-status-complete');
    window.setTimeout(() => {
      missionStatus.classList.remove('mission-status-complete');
    }, 420);
  }

  function updateCompass() {
    if (!targetCompass || compassDots.length === 0) {
      return;
    }
    if (primaryObjective && !primaryObjective.completed) {
      targetCompass.style.setProperty('--compass-highlight-rgb', formatRgbComponents(primaryObjective.color));
    } else {
      targetCompass.style.removeProperty('--compass-highlight-rgb');
    }
    compassVectors.forward.set(0, 0, -1).applyQuaternion(camera.quaternion);
    compassDots.forEach(({ marker, dot }) => {
      compassVectors.world.copy(marker.group.position);
      compassVectors.ndc.copy(compassVectors.world).project(camera);
      const clampedX = Math.max(-0.9, Math.min(0.9, compassVectors.ndc.x));
      dot.style.left = `${(clampedX * 0.5 + 0.5) * 100}%`;
      const isBehind = compassVectors.ndc.z > 1;
      const isOffscreen = Math.abs(compassVectors.ndc.x) > 1 || compassVectors.ndc.y > 1;
      dot.classList.toggle('is-behind', isBehind);
      dot.classList.toggle('is-offscreen', !isBehind && isOffscreen);
      dot.classList.toggle('is-complete', marker.completed);
      const isPrimary = !marker.completed && marker === primaryObjective;
      dot.classList.toggle('is-primary', isPrimary);
      if (isPrimary) {
        dot.style.setProperty('--dot-highlight-rgb', formatRgbComponents(marker.color));
      } else {
        dot.style.removeProperty('--dot-highlight-rgb');
      }
      compassVectors.direction.copy(marker.group.position).sub(camera.position);
      const distance = compassVectors.direction.length();
      const distanceFade = Math.max(0.35, Math.min(1, 900 / Math.max(distance, 1)));
      let opacity = marker.completed ? 0.28 : 0.55 + distanceFade * 0.3;
      if (isPrimary) {
        opacity = 0.92;
      } else if (isBehind) {
        opacity = Math.max(0.35, opacity - 0.18);
      }
      if (!isBehind && isOffscreen) {
        opacity = Math.min(opacity, 0.45);
      }
      dot.style.opacity = opacity.toString();
    });
  }

  function reseedObjective(marker) {
    marker.completed = false;
    marker.group.scale.setScalar(1);
    marker.group.position.copy(randomizeObjectivePosition(marker.basePosition));
    marker.core.material.color.setHex(marker.color);
    marker.core.material.emissive.setHex(marker.color);
    marker.core.material.emissiveIntensity = 0.9;
    marker.core.material.opacity = 0.92;
    marker.ring.material.color.setHex(marker.color);
    marker.ring.material.opacity = 0.36;
    marker.pylon.material.color.setHex(marker.color);
    marker.pylon.material.opacity = 0;
    marker.pylon.visible = false;
    marker.glow.material.color.set(new THREE.Color(marker.color));
    marker.glow.material.opacity = 0.42;
  }

  function completeObjective(marker) {
    if (marker.completed) {
      return;
    }
    awardScore(10, { amount: 10, label: `${marker.name} synchronized`, unit: 'points' });
    marker.completed = true;
    marker.group.scale.setScalar(1.08);
    marker.core.material.color.setHex(marker.color);
    marker.core.material.emissive.setHex(marker.color);
    marker.core.material.emissiveIntensity = 0.4;
    marker.core.material.opacity = 0.72;
    marker.ring.material.color.setHex(marker.color);
    marker.ring.material.opacity = 0.18;
    marker.pylon.material.opacity = 0;
    marker.pylon.visible = false;
    marker.glow.material.color.set(new THREE.Color(marker.color));
    marker.glow.material.opacity = 0.12;
    totalSyncedObjectives += 1;
    updateObjectiveUI();
    highlightMissionStatus();

    if (objectiveMarkers.every((item) => item.completed)) {
      awardScore(200, { amount: 200, label: 'Position complete', unit: 'points' });
      window.setTimeout(() => {
        objectiveMarkers.forEach((item) => {
          reseedObjective(item);
        });
        updateObjectiveUI();
      }, 1600);
    }
  }

  const asteroidGeometry = new THREE.IcosahedronGeometry(2.6, 1);
  const asteroidMaterial = new THREE.MeshStandardMaterial({
    color: 0x475569,
    flatShading: true,
    metalness: 0.1,
    roughness: 0.85
  });
  const asteroidCount = 110;
  const asteroids = new THREE.InstancedMesh(asteroidGeometry, asteroidMaterial, asteroidCount);
  const asteroidInfos = [];
  const tempMatrix = new THREE.Matrix4();
  const tempQuaternion = new THREE.Quaternion();

  function randomAsteroidPosition() {
    return new THREE.Vector3(
      (Math.random() - 0.5) * 900,
      (Math.random() - 0.5) * 360,
      -300 - Math.random() * 1800
    );
  }

  for (let i = 0; i < asteroidCount; i++) {
    const position = randomAsteroidPosition();
    const scale = 0.6 + Math.random() * 2.1;
    const rotation = new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    const rotationDelta = new THREE.Vector3(
      (Math.random() - 0.5) * 0.6,
      (Math.random() - 0.5) * 0.5,
      (Math.random() - 0.5) * 0.6
    );
    const drift = new THREE.Vector3((Math.random() - 0.5) * 0.8, (Math.random() - 0.5) * 0.4, 18 + Math.random() * 22);
    asteroidInfos.push({ position, scale, rotation, rotationDelta, drift });
    tempQuaternion.setFromEuler(rotation);
    tempMatrix.compose(position, tempQuaternion, new THREE.Vector3(scale, scale, scale));
    asteroids.setMatrixAt(i, tempMatrix);
  }
  asteroids.instanceMatrix.needsUpdate = true;
  scene.add(asteroids);

  const shipGeometry = new THREE.ConeGeometry(2.4, 6.5, 12);
  const shipMaterial = new THREE.MeshStandardMaterial({
    color: 0xf8fafc,
    emissive: 0x38bdf8,
    emissiveIntensity: 0.6,
    roughness: 0.4
  });
  const ship = new THREE.Mesh(shipGeometry, shipMaterial);
  const shipForwardRotation = Math.PI / 2;
  ship.rotation.x = shipForwardRotation;
  const shipScale = 0.9;
  ship.scale.set(shipScale, shipScale, shipScale);
  camera.add(ship);
  // Lower and nudge the ship forward so the reticle stays clear while the classic
  // silhouette remains visible in frame.
  ship.position.set(0, -2.6, -5.85);
  scene.add(camera);

  const streakGroup = new THREE.Group();
  streakGroup.position.set(0, 0, -4);
  camera.add(streakGroup);
  const streakGeometry = new THREE.PlaneGeometry(0.12, 1.8);
  const streakMaterial = new THREE.MeshBasicMaterial({
    color: 0x38bdf8,
    transparent: true,
    opacity: 0.65,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false
  });
  const streaks = [];
  for (let i = 0; i < 140; i++) {
    const streak = new THREE.Mesh(streakGeometry, streakMaterial);
    resetStreak(streak, true);
    streakGroup.add(streak);
    streaks.push({ mesh: streak, speed: 18 + Math.random() * 26 });
  }

  function resetStreak(mesh, movingForward = true) {
    mesh.position.set(
      (Math.random() - 0.5) * 18,
      (Math.random() - 0.5) * 12,
      movingForward ? -Math.random() * 60 - 8 : -Math.random() * 6 - 2
    );
    const length = 0.6 + Math.random() * 2.4;
    mesh.scale.set(1, length, 1);
    mesh.rotation.x = Math.PI / 2;
  }

  const engineGeometry = new THREE.CylinderGeometry(0.6, 1.8, 2.5, 16, 1, true);
  const engineMaterial = new THREE.MeshBasicMaterial({
    color: 0x38bdf8,
    transparent: true,
    opacity: 0.4,
    blending: THREE.AdditiveBlending
  });
  const engineFlare = new THREE.Mesh(engineGeometry, engineMaterial);
  engineFlare.rotation.x = shipForwardRotation;
  engineFlare.position.set(0, -2.4, -7.4);
  engineFlare.scale.set(shipScale, shipScale, shipScale);
  camera.add(engineFlare);

  const clock = new THREE.Clock();
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();
  let forwardSpeed = 0;
  let lastForwardDirection = 1;
  const planetHitPosition = new THREE.Vector3();
  const upVector = new THREE.Vector3(0, 1, 0);

  const actionButtons = touchUI ? [...touchUI.querySelectorAll('.touch-action')] : [];
  let pauseButton = null;
  let recenterButton = null;
  const momentaryResetters = new Map();
  const moveInput = { x: 0, y: 0 };
  let throttleValue = 0;
  const touchActions = {
    boost: false,
    fire: false,
    ascend: false,
    descend: false,
    strafeLeft: false,
    strafeRight: false
  };
  let paused = false;
  const defaultCruiseThrottle = 0.35;
  // Match the steady-state drift produced by the default throttle in pointer mode so desktop players
  // still lift off with a gentle glide without locking in a persistent forward creep.
  const pointerCruiseSpeed = (defaultCruiseThrottle * 24) / 0.6;
  let initialCruiseEngaged = false;

  const coarsePointerQuery = window.matchMedia('(pointer: coarse)');
  const finePointerQuery = window.matchMedia('(pointer: fine)');
  const hasTouchPoints = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  let usingTouchControls = coarsePointerQuery.matches || (!finePointerQuery.matches && hasTouchPoints);
  let manualControlPreference = false;
  let touchLookPointer = null;
  let lastLookX = 0;
  let lastLookY = 0;

  if (overlayToggle) {
    overlayToggle.setAttribute('aria-hidden', 'true');
  }

  function setOverlayVisible(visible) {
    if (!overlay) {
      return;
    }
    overlay.classList.toggle('overlay-hidden', !visible);
    overlay.setAttribute('aria-hidden', visible ? 'false' : 'true');
    if (overlayToggle) {
      overlayToggle.classList.toggle('overlay-toggle-visible', !visible);
      overlayToggle.setAttribute('aria-hidden', visible ? 'true' : 'false');
    }
  }

  function setThrottleValue(value) {
    throttleValue = Math.max(-1, Math.min(1, value));
    moveInput.y = -throttleValue;
    if (throttleControl) {
      throttleControl.setAttribute('aria-valuenow', `${Math.round(throttleValue * 100)}`);
    }
    if (throttleTrack && throttleThumb && throttleLevel) {
      const percent = (throttleValue + 1) / 2;
      throttleThumb.style.top = `${(1 - percent) * 100}%`;
      const forward = Math.max(0, throttleValue);
      const reverse = Math.max(0, -throttleValue);
      throttleLevel.style.height = `${forward * 100}%`;
      if (throttleReverse) {
        throttleReverse.style.height = `${reverse * 100}%`;
      }
    }
  }

  function clearTouchInputs() {
    moveInput.x = 0;
    setThrottleValue(0);
    touchActions.boost = false;
    touchActions.fire = false;
    touchActions.ascend = false;
    touchActions.descend = false;
    touchActions.strafeLeft = false;
    touchActions.strafeRight = false;
    actionButtons
      .filter((button) => button.dataset.action !== 'pause' && button.dataset.action !== 'recenter')
      .forEach((button) => button.setAttribute('aria-pressed', 'false'));
    momentaryResetters.forEach((resetter) => {
      if (typeof resetter === 'function') {
        resetter();
      }
    });
  }

  if (usingTouchControls) {
    setThrottleValue(defaultCruiseThrottle);
  }

  function updateInstructionCopy() {
    if (!primaryInstructions || !secondaryInstructions) {
      return;
    }
    if (usingTouchControls) {
      primaryInstructions.innerHTML =
        [
          'Tap anywhere to arm the flight deck, then swipe across space to steer your ship.',
          'Drag the vertical throttle to set forward cruise or reverse drift, and tap <strong>Fire</strong> to launch a laser burst.'
        ].join(' ');
      secondaryInstructions.innerHTML =
        [
          'Hold Boost to surge forward, Strafe or Ascend/Descend to slide and climb, and Re-center to reset orientation.',
          'Tag luminous objective beacons to sync this sector‚Äîthe mission tracker keeps score while Pause freezes the ship.'
        ].join(' ');
    } else {
      primaryInstructions.innerHTML =
        [
          'Glide through procedurally scattered stars and luminous worlds. Click anywhere to engage flight controls,',
          'then use your mouse to look and <strong>WASD</strong> to steer. Hold <strong>Shift</strong> to boost and left-click or press <strong>F</strong> to fire a laser burst.'
        ].join(' ');
      secondaryInstructions.innerHTML =
        [
          'Press <strong>R</strong> to re-center your ship. Pointer lock keeps the cursor inside the cockpit‚Äîpress <strong>Esc</strong> to release.',
          'Tag the luminous mission beacons to complete objectives and watch the tracker for your next target.'
        ].join(' ');
    }
  }

  function setControlMode(useTouch) {
    usingTouchControls = useTouch;
    document.body.classList.toggle('touch-enabled', useTouch);
    if (touchUI) {
      touchUI.setAttribute('aria-hidden', useTouch ? 'false' : 'true');
    }
    if (controlModeToggle) {
      controlModeToggle.setAttribute('aria-pressed', useTouch ? 'true' : 'false');
      controlModeToggle.textContent = useTouch ? 'Touch Controls: On' : 'Touch Controls: Off';
    }
    if (!useTouch) {
      clearTouchInputs();
    }
    paused = false;
    if (pauseButton) {
      pauseButton.setAttribute('aria-pressed', 'false');
      pauseButton.textContent = 'Pause';
    }
    if (useTouch && document.pointerLockElement === renderer.domElement) {
      document.exitPointerLock();
    }
    if (!useTouch) {
      touchLookPointer = null;
    } else {
      setThrottleValue(0);
      if (touchGestureHint) {
        touchGestureHint.classList.remove('touch-gesture-hint-hidden');
      }
    }
    updateInstructionCopy();
  }

  function engageInitialCruise() {
    if (initialCruiseEngaged) {
      return;
    }
    if (usingTouchControls) {
      setThrottleValue(defaultCruiseThrottle);
    } else {
      velocity.set(0, 0, -pointerCruiseSpeed);
      forwardSpeed = pointerCruiseSpeed;
    }
    initialCruiseEngaged = true;
  }

  function evaluatePointerPreference() {
    if (manualControlPreference) {
      return;
    }
    const shouldUseTouch = coarsePointerQuery.matches || (!finePointerQuery.matches && hasTouchPoints);
    setControlMode(shouldUseTouch);
  }

  setControlMode(usingTouchControls);
  engageInitialCruise();

  function bindThrottleControl() {
    if (!throttleControl || !throttleTrack) {
      return;
    }
    let activePointer = null;

    function updateFromEvent(event) {
      const rect = throttleTrack.getBoundingClientRect();
      if (!rect.height) {
        return;
      }
      const clampedY = Math.max(rect.top, Math.min(rect.bottom, event.clientY));
      const normalized = 1 - (clampedY - rect.top) / rect.height;
      const value = normalized * 2 - 1;
      setThrottleValue(value);
    }

    const releasePointer = (event) => {
      if (activePointer === null || (event && event.pointerId !== activePointer)) {
        return;
      }
      if (throttleControl.hasPointerCapture && throttleControl.hasPointerCapture(activePointer)) {
        throttleControl.releasePointerCapture(activePointer);
      }
      activePointer = null;
    };

    throttleControl.addEventListener('pointerdown', (event) => {
      if (!usingTouchControls || activePointer !== null) {
        return;
      }
      activePointer = event.pointerId;
      throttleControl.setPointerCapture(activePointer);
      updateFromEvent(event);
      event.preventDefault();
      event.stopPropagation();
    });

    throttleControl.addEventListener('pointermove', (event) => {
      if (event.pointerId !== activePointer) {
        return;
      }
      updateFromEvent(event);
    });

    throttleControl.addEventListener('pointerup', releasePointer);
    throttleControl.addEventListener('pointercancel', releasePointer);
    throttleControl.addEventListener('lostpointercapture', () => {
      activePointer = null;
    });

    throttleControl.addEventListener('dblclick', (event) => {
      event.preventDefault();
      setThrottleValue(0);
    });
  }

  bindThrottleControl();

  function bindMomentaryAction(button, actionKey) {
    if (!button) {
      return null;
    }
    let activePointer = null;

    const setPressed = (pressed) => {
      touchActions[actionKey] = pressed;
      button.setAttribute('aria-pressed', pressed ? 'true' : 'false');
    };

    const resetState = () => {
      if (activePointer !== null && button.hasPointerCapture && button.hasPointerCapture(activePointer)) {
        button.releasePointerCapture(activePointer);
      }
      activePointer = null;
      setPressed(false);
    };

    const release = (event) => {
      if (activePointer === null || (event && event.pointerId !== activePointer)) {
        return;
      }
      resetState();
    };

    button.addEventListener('pointerdown', (event) => {
      if (!usingTouchControls || activePointer !== null) {
        return;
      }
      activePointer = event.pointerId;
      button.setPointerCapture(activePointer);
      setPressed(true);
      if (actionKey === 'fire') {
        triggerLaserBurst();
      }
      event.preventDefault();
      event.stopPropagation();
    });

    button.addEventListener('pointerup', release);
    button.addEventListener('pointercancel', release);
    button.addEventListener('lostpointercapture', resetState);

    return resetState;
  }

  momentaryResetters.set('boost', bindMomentaryAction(actionButtons.find((btn) => btn.dataset.action === 'boost'), 'boost'));
  momentaryResetters.set('fire', bindMomentaryAction(actionButtons.find((btn) => btn.dataset.action === 'fire'), 'fire'));
  momentaryResetters.set(
    'ascend',
    bindMomentaryAction(actionButtons.find((btn) => btn.dataset.action === 'ascend'), 'ascend')
  );
  momentaryResetters.set(
    'descend',
    bindMomentaryAction(actionButtons.find((btn) => btn.dataset.action === 'descend'), 'descend')
  );
  momentaryResetters.set(
    'strafeLeft',
    bindMomentaryAction(actionButtons.find((btn) => btn.dataset.action === 'strafe-left'), 'strafeLeft')
  );
  momentaryResetters.set(
    'strafeRight',
    bindMomentaryAction(actionButtons.find((btn) => btn.dataset.action === 'strafe-right'), 'strafeRight')
  );

  pauseButton = actionButtons.find((btn) => btn.dataset.action === 'pause');
  if (pauseButton) {
    pauseButton.addEventListener('click', (event) => {
      event.preventDefault();
      paused = !paused;
      pauseButton.setAttribute('aria-pressed', paused ? 'true' : 'false');
      pauseButton.textContent = paused ? 'Resume' : 'Pause';
    });
  }

  recenterButton = actionButtons.find((btn) => btn.dataset.action === 'recenter');
  if (recenterButton) {
    recenterButton.addEventListener('click', (event) => {
      event.preventDefault();
      recenterShip();
    });
  }

  if (controlModeToggle) {
    controlModeToggle.addEventListener('click', () => {
      manualControlPreference = true;
      setControlMode(!usingTouchControls);
    });
  }

  const pointerPreferenceHandler = () => evaluatePointerPreference();
  if (coarsePointerQuery.addEventListener) {
    coarsePointerQuery.addEventListener('change', pointerPreferenceHandler);
    finePointerQuery.addEventListener('change', pointerPreferenceHandler);
  } else if (coarsePointerQuery.addListener) {
    coarsePointerQuery.addListener(pointerPreferenceHandler);
    finePointerQuery.addListener(pointerPreferenceHandler);
  }

  if (overlayClose) {
    overlayClose.addEventListener('click', (event) => {
      event.stopPropagation();
      setOverlayVisible(false);
      if (overlayToggle) {
        overlayToggle.focus({ preventScroll: true });
      }
    });
  }

  if (overlayToggle) {
    overlayToggle.addEventListener('click', () => {
      setOverlayVisible(true);
      if (overlayClose) {
        overlayClose.focus({ preventScroll: true });
      }
    });
  }

  const keys = new Set();
  let yaw = 0;
  let pitch = 0;
  let pointerLocked = false;
  const pitchLimit = Math.PI / 2 - 0.08;

  const laserLength = 22;
  const laserCoreGeometry = new THREE.CylinderGeometry(0.08, 0.08, laserLength, 12);
  const laserGlowGeometry = new THREE.CylinderGeometry(0.28, 0.28, laserLength, 16, 1, true);
  const laserTipHeight = 2.4;
  const laserTipGeometry = new THREE.ConeGeometry(0.34, laserTipHeight, 16);
  const baseLaserCoreMaterial = new THREE.MeshBasicMaterial({
    color: 0x7dd3fc,
    transparent: true,
    opacity: 0.95,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    depthTest: false
  });
  const baseLaserGlowMaterial = new THREE.MeshBasicMaterial({
    color: 0x38bdf8,
    transparent: true,
    opacity: 0.42,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    depthTest: false
  });
  const baseLaserTipMaterial = new THREE.MeshBasicMaterial({
    color: 0xfcd34d,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    depthTest: false
  });
  const activeLasers = [];
  const laserForwardAxis = new THREE.Vector3(0, 1, 0);
  const laserSpeed = 220;
  const laserLifetime = 1.8;
  const laserCooldownMs = 160;
  let lastLaserTimestamp = 0;

  function removeLaser(index) {
    const shot = activeLasers[index];
    scene.remove(shot.group);
    shot.group.traverse((part) => {
      if (part.isMesh && part.material) {
        part.material.dispose();
      }
    });
    activeLasers.splice(index, 1);
  }

  function triggerLaserBurst() {
    if (paused) {
      return;
    }
    const now = performance.now();
    if (now - lastLaserTimestamp < laserCooldownMs) {
      return;
    }
    lastLaserTimestamp = now;
    const directionVector = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ')).normalize();
    const laserGroup = new THREE.Group();
    const core = new THREE.Mesh(laserCoreGeometry, baseLaserCoreMaterial.clone());
    core.userData.baseOpacity = core.material.opacity;
    core.renderOrder = 2;
    laserGroup.add(core);
    const glow = new THREE.Mesh(laserGlowGeometry, baseLaserGlowMaterial.clone());
    glow.userData.baseOpacity = glow.material.opacity;
    glow.renderOrder = 1;
    laserGroup.add(glow);
    const tip = new THREE.Mesh(laserTipGeometry, baseLaserTipMaterial.clone());
    tip.position.y = laserLength / 2 + laserTipHeight * 0.5;
    tip.userData.baseOpacity = tip.material.opacity;
    tip.renderOrder = 3;
    laserGroup.add(tip);
    laserGroup.position.copy(camera.position).addScaledVector(directionVector, 6 + laserLength * 0.45);
    laserGroup.quaternion.copy(new THREE.Quaternion().setFromUnitVectors(laserForwardAxis, directionVector));
    scene.add(laserGroup);
    activeLasers.push({
      group: laserGroup,
      direction: directionVector,
      life: 0,
      pulseOffset: Math.random() * Math.PI * 2,
      parts: { core, glow, tip }
    });
  }

  function updateLasers(delta) {
    for (let index = activeLasers.length - 1; index >= 0; index--) {
      const shot = activeLasers[index];
      shot.life += delta;
      shot.group.position.addScaledVector(shot.direction, delta * laserSpeed);
      const fade = Math.max(0, 1 - shot.life / laserLifetime);
      const pulse = 1 + Math.sin(shot.life * 18 + shot.pulseOffset) * 0.18 * fade;
      shot.group.scale.x = 1 + pulse * 0.4;
      shot.group.scale.y = 1;
      shot.group.scale.z = 1 + pulse * 0.4;
      const { core, glow, tip } = shot.parts;
      if (core.material) {
        core.material.opacity = core.userData.baseOpacity * fade;
      }
      if (glow.material) {
        glow.material.opacity = glow.userData.baseOpacity * (0.5 + fade * 0.75);
      }
      if (tip.material) {
        tip.material.opacity = tip.userData.baseOpacity * fade;
      }

      let shouldRemove = shot.life > laserLifetime;

      if (!shouldRemove) {
        for (const marker of objectiveMarkers) {
          if (marker.completed) {
            continue;
          }
          if (shot.group.position.distanceTo(marker.group.position) <= marker.hitRadius) {
            completeObjective(marker);
            shouldRemove = true;
            break;
          }
        }
      }

      if (!shouldRemove) {
        for (const target of planetTargets) {
          target.planet.getWorldPosition(planetHitPosition);
          if (shot.group.position.distanceTo(planetHitPosition) <= target.hitRadius) {
            registerPlanetHit(target);
            shouldRemove = true;
            break;
          }
        }
      }

      if (shouldRemove) {
        removeLaser(index);
      }
    }
  }

  function recenterShip() {
    camera.position.set(0, 0, 20);
    velocity.set(0, 0, 0);
    yaw = 0;
    pitch = 0;
  }

  function updateStatus(speed) {
    if (!statusEl) {
      return;
    }
    const boostEngaged = touchActions.boost || keys.has('ShiftLeft') || keys.has('ShiftRight');
    const modeLabel = paused ? 'PAUSED' : boostEngaged ? 'BOOST CHANNEL' : 'CRUISE MODE';
    const displayedSpeed = paused ? 0 : speed;
    statusEl.innerHTML = `VELOCITY <span>${displayedSpeed.toFixed(1)}</span> U/S<br>${modeLabel}`;
  }

  updateStatus(0);

  window.addEventListener('keydown', (event) => {
    keys.add(event.code);
    if (event.code === 'KeyR') {
      recenterShip();
    }
    if (event.code === 'KeyF') {
      event.preventDefault();
      triggerLaserBurst();
    }
  });

  window.addEventListener('keyup', (event) => {
    keys.delete(event.code);
  });

  renderer.domElement.addEventListener('click', () => {
    if (usingTouchControls) {
      setOverlayVisible(false);
      return;
    }
    renderer.domElement.requestPointerLock();
    setOverlayVisible(false);
  });

  renderer.domElement.addEventListener('mousedown', (event) => {
    if (!pointerLocked || event.button !== 0) {
      return;
    }
    event.preventDefault();
    triggerLaserBurst();
  });

  document.addEventListener('pointerlockchange', () => {
    pointerLocked = document.pointerLockElement === renderer.domElement;
    if (pointerLocked) {
      setOverlayVisible(false);
    }
  });

  document.addEventListener('mousemove', (event) => {
    if (!pointerLocked) {
      return;
    }
    yaw -= event.movementX * 0.0022;
    pitch -= event.movementY * 0.0022;
    pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
  });

  function isTouchLikePointer(event) {
    return event.pointerType === 'touch' || event.pointerType === 'pen' || event.pointerType === '';
  }

  renderer.domElement.addEventListener('pointerdown', (event) => {
    if (!usingTouchControls || !isTouchLikePointer(event)) {
      return;
    }
    if (event.target.closest && event.target.closest('.touch-ui')) {
      return;
    }
    touchLookPointer = event.pointerId;
    lastLookX = event.clientX;
    lastLookY = event.clientY;
    if (touchGestureHint) {
      touchGestureHint.classList.add('touch-gesture-hint-hidden');
    }
    setOverlayVisible(false);
    event.preventDefault();
  });

  window.addEventListener('pointermove', (event) => {
    if (!usingTouchControls || event.pointerId !== touchLookPointer) {
      return;
    }
    const dx = event.clientX - lastLookX;
    const dy = event.clientY - lastLookY;
    lastLookX = event.clientX;
    lastLookY = event.clientY;
    yaw -= dx * 0.0032;
    pitch -= dy * 0.0026;
    pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
  });

  function releaseTouchLook(pointerId) {
    if (touchLookPointer !== null && touchLookPointer === pointerId) {
      touchLookPointer = null;
    }
  }

  window.addEventListener('pointerup', (event) => {
    if (!usingTouchControls) {
      return;
    }
    releaseTouchLook(event.pointerId);
  });

  window.addEventListener('pointercancel', (event) => {
    if (!usingTouchControls) {
      return;
    }
    releaseTouchLook(event.pointerId);
  });

  function updateMovement(delta) {
    const dampening = 1 - Math.min(delta * 0.6, 0.18);
    velocity.multiplyScalar(dampening);

    pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));

    direction.set(0, 0, -1).applyEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
    const right = new THREE.Vector3().crossVectors(direction, upVector).normalize();
    const vertical = new THREE.Vector3().crossVectors(right, direction).normalize();

    if (paused) {
      velocity.set(0, 0, 0);
      forwardSpeed = 0;
      camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
      const stabilityPaused = Math.max(0, Math.min(1, 1 - Math.abs(pitch) / pitchLimit));
      if (speedBar) {
        speedBar.style.transform = 'scaleX(0.1)';
      }
      if (stabilityBar) {
        stabilityBar.style.transform = `scaleX(${0.2 + stabilityPaused * 0.8})`;
      }
      updateStatus(0);
      return;
    }

    const boostEngaged = touchActions.boost || keys.has('ShiftLeft') || keys.has('ShiftRight');
    const acceleration = boostEngaged ? 60 : 24;
    const analogThreshold = 0.05;
    const strafeInput = (touchActions.strafeRight ? 1 : 0) - (touchActions.strafeLeft ? 1 : 0);

    if (keys.has('KeyW')) {
      velocity.addScaledVector(direction, acceleration * delta);
    }
    if (keys.has('KeyS')) {
      velocity.addScaledVector(direction, -acceleration * delta);
    }
    if (keys.has('KeyA')) {
      velocity.addScaledVector(right, -acceleration * delta);
    }
    if (keys.has('KeyD')) {
      velocity.addScaledVector(right, acceleration * delta);
    }
    if (keys.has('Space')) {
      velocity.addScaledVector(vertical, acceleration * delta);
    }
    if (keys.has('ControlLeft') || keys.has('ControlRight')) {
      velocity.addScaledVector(vertical, -acceleration * delta);
    }

    if (Math.abs(moveInput.y) > analogThreshold) {
      velocity.addScaledVector(direction, -moveInput.y * acceleration * delta);
    }
    if (strafeInput !== 0) {
      velocity.addScaledVector(right, strafeInput * acceleration * delta);
    }
    if (touchActions.ascend) {
      velocity.addScaledVector(vertical, acceleration * delta);
    }
    if (touchActions.descend) {
      velocity.addScaledVector(vertical, -acceleration * delta);
    }

    const maxSpeed = boostEngaged ? 125 : 68;
    if (velocity.length() > maxSpeed) {
      velocity.setLength(maxSpeed);
    }

    camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
    camera.position.addScaledVector(velocity, delta);

    forwardSpeed = velocity.dot(direction);
    const speed = velocity.length();
    const stability = Math.max(0, Math.min(1, 1 - Math.abs(pitch) / pitchLimit));
    if (speedBar) {
      speedBar.style.transform = `scaleX(${0.1 + Math.min(speed / 125, 1) * 0.9})`;
    }
    if (stabilityBar) {
      stabilityBar.style.transform = `scaleX(${0.2 + stability * 0.8})`;
    }
    updateStatus(speed);
  }

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    if (usingTouchControls && touchActions.fire) {
      triggerLaserBurst();
    }
    updateMovement(delta);
    updateLasers(delta);

    starLayers.forEach((layer, index) => {
      layer.points.rotation.y += delta * layer.rotationSpeed * (index + 1);
      layer.points.rotation.x += delta * layer.rotationSpeed * 0.5;
    });

    nebulae.forEach((item) => {
      item.mesh.rotation.y += delta * 0.02;
      item.mesh.position.addScaledVector(item.drift, delta * 0.5);
      if (item.mesh.position.z > 200) {
        item.mesh.position.copy(new THREE.Vector3(
          (Math.random() - 0.5) * 1200,
          (Math.random() - 0.5) * 640,
          -600 - Math.random() * 1800
        ));
      }
    });

    anomalies.forEach((anomaly) => {
      anomaly.pulse += delta * anomaly.speed;
      anomaly.sprite.material.opacity = anomaly.baseOpacity + Math.sin(anomaly.pulse) * 0.18;
      anomaly.sprite.position.z += delta * 14;
      if (anomaly.sprite.position.z > 120) {
        anomaly.sprite.position.set(
          (Math.random() - 0.5) * 1100,
          (Math.random() - 0.5) * 660,
          -500 - Math.random() * 2200
        );
      }
    });

    objectiveMarkers.forEach((marker) => {
      const isPrimary = !marker.completed && marker === primaryObjective;
      const pulseSpeed = marker.completed ? 0.9 : isPrimary ? 2.3 : 1.6;
      marker.pulse += delta * pulseSpeed;
      marker.group.rotation.y += delta * 0.28;
      marker.ring.rotation.z += delta * 0.42;
      if (marker.completed) {
        const settledScale = 1.04 + Math.sin(marker.pulse * 0.45) * 0.03;
        marker.group.scale.setScalar(settledScale);
        marker.ring.material.opacity = 0.12 + Math.sin(marker.pulse) * 0.03;
        marker.pylon.visible = false;
        marker.pylon.material.opacity = 0;
        marker.core.material.emissiveIntensity = 0.3 + Math.sin(marker.pulse * 0.4) * 0.05;
        marker.glow.material.opacity = 0.05 + Math.max(0, Math.sin(marker.pulse * 0.4)) * 0.04;
      } else if (isPrimary) {
        marker.pylon.visible = true;
        const radiantScale = 1.1 + Math.sin(marker.pulse * 0.55) * 0.18;
        marker.group.scale.setScalar(radiantScale);
        marker.ring.material.opacity = 0.46 + Math.sin(marker.pulse * 0.9) * 0.22;
        marker.pylon.material.opacity = 0.34 + Math.sin(marker.pulse * 0.65) * 0.08;
        marker.core.material.emissiveIntensity = 1.15 + Math.sin(marker.pulse) * 0.35;
        marker.glow.material.opacity = 0.5 + Math.sin(marker.pulse * 1.1) * 0.14;
      } else {
        marker.pylon.visible = false;
        marker.pylon.material.opacity = 0;
        const breathingScale = 1 + Math.sin(marker.pulse * 0.5) * 0.08;
        marker.group.scale.setScalar(breathingScale);
        marker.ring.material.opacity = 0.32 + Math.sin(marker.pulse) * 0.14;
        marker.core.material.emissiveIntensity = 0.85 + Math.sin(marker.pulse) * 0.18;
        marker.glow.material.opacity = 0.38 + Math.sin(marker.pulse) * 0.08;
      }
    });

    planets.forEach((planet, index) => {
      planet.rotation.y += delta * (0.04 + index * 0.018);
      planet.userData.floatPhase += delta * 0.6;
      planet.position.y = planet.userData.baseY + Math.sin(planet.userData.floatPhase) * 8;
      if (planet.userData.ring) {
        planet.userData.ring.rotation.z += delta * 0.05;
        planet.userData.ring.position.y = planet.position.y;
      }
      if (planet.userData.hitDuration > 0) {
        planet.userData.hitElapsed += delta;
        const progress = Math.min(planet.userData.hitElapsed / planet.userData.hitDuration, 1);
        const pulse = Math.sin(progress * Math.PI);
        planet.scale.setScalar((planet.userData.baseScale || 1) + pulse * 0.06);
        if (planet.material) {
          planet.material.emissiveIntensity = (planet.userData.baseEmissive || 0) + pulse * 0.5;
        }
        if (planet.userData.ring) {
          const ring = planet.userData.ring;
          const baseOpacity = ring.userData?.baseOpacity ?? 0.28;
          const baseScale = ring.userData?.baseScale ?? 1;
          ring.material.opacity = baseOpacity + pulse * 0.25;
          ring.scale.setScalar(baseScale + pulse * 0.12);
        }
        if (progress >= 1) {
          planet.userData.hitDuration = 0;
          planet.userData.hitElapsed = 0;
          planet.scale.setScalar(planet.userData.baseScale || 1);
          if (planet.material) {
            planet.material.emissiveIntensity = planet.userData.baseEmissive || 0;
          }
          if (planet.userData.ring) {
            const ring = planet.userData.ring;
            const baseOpacity = ring.userData?.baseOpacity ?? 0.28;
            const baseScale = ring.userData?.baseScale ?? 1;
            ring.material.opacity = baseOpacity;
            ring.scale.setScalar(baseScale);
          }
        }
      } else {
        if (planet.scale.x !== (planet.userData.baseScale || 1)) {
          planet.scale.setScalar(planet.userData.baseScale || 1);
        }
        if (planet.material && planet.material.emissiveIntensity !== (planet.userData.baseEmissive || 0)) {
          planet.material.emissiveIntensity = planet.userData.baseEmissive || 0;
        }
        if (planet.userData.ring) {
          const ring = planet.userData.ring;
          const baseOpacity = ring.userData?.baseOpacity ?? 0.28;
          const baseScale = ring.userData?.baseScale ?? 1;
          if (ring.material.opacity !== baseOpacity) {
            ring.material.opacity = baseOpacity;
          }
          if (ring.scale.x !== baseScale || ring.scale.y !== baseScale || ring.scale.z !== baseScale) {
            ring.scale.setScalar(baseScale);
          }
        }
      }
    });

    planetPivots.forEach((pivot, index) => {
      pivot.rotation.y += delta * (0.02 + index * 0.01);
    });

    asteroidInfos.forEach((info, instanceIndex) => {
      info.rotation.x += delta * info.rotationDelta.x;
      info.rotation.y += delta * info.rotationDelta.y;
      info.rotation.z += delta * info.rotationDelta.z;
      info.position.addScaledVector(info.drift, delta * 0.6);
      info.position.z += delta * (velocity.length() * 0.45);
      if (info.position.z > 140) {
        info.position.copy(randomAsteroidPosition());
      }
      tempQuaternion.setFromEuler(info.rotation);
      tempMatrix.compose(info.position, tempQuaternion, new THREE.Vector3(info.scale, info.scale, info.scale));
      asteroids.setMatrixAt(instanceIndex, tempMatrix);
    });
    asteroids.instanceMatrix.needsUpdate = true;

    const forwardMagnitude = Math.abs(forwardSpeed);
    const forwardDirection = forwardMagnitude > 0.01 ? Math.sign(forwardSpeed) : 0;
    if (forwardDirection !== 0 && forwardDirection !== lastForwardDirection) {
      streaks.forEach((streak) => {
        resetStreak(streak.mesh, forwardDirection > 0);
      });
      lastForwardDirection = forwardDirection;
    }
    const normalizedForward = forwardDirection === 0 ? 0 : THREE.MathUtils.clamp(forwardMagnitude / 60, 0, 1.2);
    streaks.forEach((streak) => {
      if (forwardDirection === 0) {
        return;
      }
      const streakDrift = forwardDirection * (streak.speed * normalizedForward + forwardMagnitude * 0.35);
      streak.mesh.position.z += delta * streakDrift;
      if (forwardDirection > 0) {
        if (streak.mesh.position.z > -2) {
          resetStreak(streak.mesh, true);
        }
      } else if (streak.mesh.position.z < -120) {
        resetStreak(streak.mesh, false);
      }
    });

    updateCompass();
    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateCompass();
  });
  </script>
</body>
</html>
