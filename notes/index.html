<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üìù 3DVR Notes</title>
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="/gun-init.js"></script>
  <script src="/pwa-install.js" defer></script>
  <link rel="stylesheet" href="../style.css?v=notes-refresh-20240204">
  <link rel="stylesheet" href="/styles/install-banner.css">
  <link rel="manifest" href="/app-manifests/notes.webmanifest">
  <meta name="theme-color" content="#0e1116">
</head>
<body class="notes-page">

  <div class="navbar">
    <div>
      <a href="../index.html">üè† Home</a>
      <a href="/tasks/">‚úÖ Tasks</a>
      <a href="./" class="active">üìù Notes</a>
      <a href="../chat.html">üí¨ Chat</a>
      <a href="../profile.html">üë§ Profile</a>
    </div>
    <div style="font-size: 0.9rem;">3DVR Portal</div>
  </div>

  <div class="install-banner" data-install-banner hidden>
    <div class="install-banner__text">
      <p class="install-banner__title">Install Notes</p>
      <p class="install-banner__meta">Access your shared notes offline with a single tap.</p>
    </div>
    <button type="button" class="install-banner__action" data-install-button>Install app</button>
  </div>

  <div class="notes-shell">
    <aside id="notes-sidebar" class="notes-sidebar" aria-label="Workspace navigation">
      <div class="workspace-header">
        <div>
          <div class="workspace-label">Workspace</div>
          <div class="workspace-title">3DVR Notes</div>
        </div>
      </div>

      <div class="sidebar-section">
        <div class="section-heading">
          <span>Spaces</span>
          <button class="icon-button" id="show-folder-input" aria-label="Add new space">Ôºã</button>
        </div>
        <input type="text" id="new-folder" class="sidebar-input hidden" placeholder="Name this space & press Enter">
        <ul id="folders" class="folders-list" aria-label="Folder list"></ul>
      </div>

      <div class="sidebar-section">
        <div class="section-heading">
          <span>Pages</span>
          <button class="primary-button" id="new-note-button" disabled>+ New Page</button>
        </div>
        <input type="search" id="note-search" class="sidebar-input" placeholder="Search pages..." aria-label="Search notes">
        <ul id="notes" class="notes-list" aria-label="Notes"></ul>
      </div>
    </aside>

    <div id="mobile-sidebar-backdrop" class="mobile-sidebar-backdrop" aria-hidden="true"></div>

    <main class="notes-editor" aria-live="polite">
      <button id="sidebar-toggle" class="sidebar-toggle icon-button" type="button" aria-label="Show workspace" aria-controls="notes-sidebar" aria-expanded="false">‚ò∞</button>
      <div id="empty-state" class="empty-state">
        <h2>Select a note to get started</h2>
        <p>Create or choose a page from the sidebar.</p>
      </div>

      <div id="editor-wrapper" class="editor-wrapper hidden" aria-label="Note editor">
        <div class="note-header">
          <div id="note-title" class="note-title" contenteditable="true" data-placeholder="Untitled"></div>
          <div id="note-meta" class="note-meta"></div>
        </div>
        <div class="note-toolbar" role="toolbar" aria-label="Formatting toolbar">
          <button class="icon-button" data-command="bold" title="Bold (Ctrl+B)"><span class="toolbar-icon">B</span></button>
          <button class="icon-button" data-command="italic" title="Italic (Ctrl+I)"><span class="toolbar-icon">I</span></button>
          <button class="icon-button" data-command="underline" title="Underline (Ctrl+U)"><span class="toolbar-icon">U</span></button>
          <div class="toolbar-divider"></div>
          <button class="icon-button" data-block="h1" title="Heading 1">H1</button>
          <button class="icon-button" data-block="h2" title="Heading 2">H2</button>
          <button class="icon-button" data-block="quote" title="Quote">‚ùù</button>
          <button class="icon-button" data-block="code" title="Code block">{;}</button>
          <div class="toolbar-divider"></div>
          <button class="icon-button" data-command="insertUnorderedList" title="Bulleted list">‚Ä¢ List</button>
          <button class="icon-button" data-command="insertOrderedList" title="Numbered list">1. List</button>
          <button class="icon-button" data-block="todo" title="To-do list">‚òëÔ∏é</button>
          <button class="icon-button" data-block="divider" title="Divider">‚Äî</button>
          <div class="toolbar-divider"></div>
          <button class="icon-button" id="insert-image-button" type="button" title="Insert image">üñºÔ∏è</button>
        </div>
        <input type="file" id="image-upload-input" class="note-image-input" accept="image/*" aria-hidden="true" tabindex="-1">
        <div id="note-content" class="note-content" contenteditable="true" data-placeholder="Start writing or type / for commands"></div>
      </div>

      <div id="slash-menu" class="slash-menu" role="menu" aria-hidden="true">
        <div class="slash-hint">Insert blocks</div>
        <ul id="slash-options"></ul>
      </div>
    </main>
  </div>

  <script>
    function createLocalGunSubscriptionStub() {
      return {
        off() {}
      };
    }

    function createLocalGunNodeStub() {
      const node = {
        __isGunStub: true,
        get() {
          return createLocalGunNodeStub();
        },
        put(_value, callback) {
          if (typeof callback === 'function') {
            setTimeout(() => callback({ err: 'gun-unavailable' }), 0);
          }
          return node;
        },
        once(callback) {
          if (typeof callback === 'function') {
            setTimeout(() => callback(undefined), 0);
          }
          return node;
        },
        on() {
          return createLocalGunSubscriptionStub();
        },
        off() {},
        map() {
          return {
            __isGunStub: true,
            on() {
              return createLocalGunSubscriptionStub();
            }
          };
        }
      };
      return node;
    }

    function createLocalGunUserStub() {
      const node = createLocalGunNodeStub();
      return {
        ...node,
        is: null,
        _: {},
        recall() {},
        auth(_alias, _password, callback) {
          if (typeof callback === 'function') {
            setTimeout(() => callback({ err: 'gun-unavailable' }), 0);
          }
        },
        leave() {},
        create(_alias, _password, callback) {
          if (typeof callback === 'function') {
            setTimeout(() => callback({ err: 'gun-unavailable' }), 0);
          }
        }
      };
    }

    function ensureGunContext(factory, label) {
      const ensureGun = window.ScoreSystem && typeof window.ScoreSystem.ensureGun === 'function'
        ? window.ScoreSystem.ensureGun.bind(window.ScoreSystem)
        : null;
      if (ensureGun) {
        return ensureGun(factory, { label });
      }
      if (typeof factory === 'function') {
        try {
          const instance = factory();
          if (instance) {
            return {
              gun: instance,
              user: typeof instance.user === 'function' ? instance.user() : createLocalGunUserStub(),
              isStub: !!instance.__isGunStub
            };
          }
        } catch (err) {
          console.warn(`Failed to initialize ${label || 'notes'} Gun instance`, err);
        }
      }
      console.warn(`Gun.js is unavailable for ${label || 'notes'}; running in offline mode.`);
      const stubGun = {
        __isGunStub: true,
        get() {
          return createLocalGunNodeStub();
        },
        user() {
          return createLocalGunUserStub();
        }
      };
      return {
        gun: stubGun,
        user: stubGun.user(),
        isStub: true
      };
    }

    const gunContext = ensureGunContext(
      () => (typeof Gun === 'function'
        ? Gun({
            peers: window.__GUN_PEERS__ || [
              'wss://relay.3dvr.tech/gun',
              'wss://gun-relay-3dvr.fly.dev/gun'
            ],
            axe: true
          })
        : null),
      'notes'
    );

    const gun = gunContext.gun;

    const portalRoot = gun && typeof gun.get === 'function'
      ? gun.get('3dvr-portal')
      : createLocalGunNodeStub();

    // Notes now live under 3dvr-portal/notes with folders in 3dvr-portal/noteFolders to align with
    // the unified portal workspace graph. Legacy simple-notes/simple-folders nodes are still observed
    // so older clients remain compatible while the data migrates forward.
    const foldersPrimary = portalRoot.get('noteFolders');
    const notesPrimary = portalRoot.get('notes');

    const foldersLegacy = gun && typeof gun.get === 'function'
      ? gun.get('simple-folders')
      : createLocalGunNodeStub();

    const notesLegacy = gun && typeof gun.get === 'function'
      ? gun.get('simple-notes')
      : createLocalGunNodeStub();

    function uniqueSources(sources) {
      return sources.filter((source, index) => source && sources.indexOf(source) === index);
    }

    const folderSources = uniqueSources([foldersPrimary, foldersLegacy]);
    const noteSources = uniqueSources([notesPrimary, notesLegacy]);

    const primaryFolderSource = folderSources[0];
    const primaryNoteSource = noteSources[0];

    function forEachSource(sources, callback) {
      sources.forEach((source, index) => {
        if (source && typeof source.get === 'function') {
          callback(source, index);
        }
      });
    }

    const isStubSource = (source) => !source || !!source.__isGunStub;

    const folderSourceRefs = new Map();
    const noteSourceRefs = new Map();

    function generateId() {
      if (typeof Gun !== 'undefined' && Gun.text && typeof Gun.text.random === 'function') {
        return Gun.text.random();
      }
      return `note_${Math.random().toString(36).slice(2)}_${Date.now().toString(36)}`;
    }

    function putToSources(sources, id, data, { onPrimaryAck } = {}) {
      forEachSource(sources, (source, index) => {
        const ref = source.get(id);
        if (!ref || typeof ref.put !== 'function') {
          return;
        }
        if (index === 0 && typeof onPrimaryAck === 'function') {
          ref.put(data, (ack) => onPrimaryAck(ack, source));
        } else {
          ref.put(data);
        }
      });
    }

    function putFieldToSources(sources, id, field, value, { onPrimaryAck } = {}) {
      forEachSource(sources, (source, index) => {
        const ref = source.get(id);
        if (!ref || typeof ref.get !== 'function') {
          return;
        }
        const child = ref.get(field);
        if (index === 0 && typeof onPrimaryAck === 'function') {
          child.put(value, (ack) => onPrimaryAck(ack, source));
        } else {
          child.put(value);
        }
      });
    }

    function removeFromSources(sources, id, { onPrimaryAck } = {}) {
      forEachSource(sources, (source, index) => {
        const ref = source.get(id);
        if (!ref || typeof ref.put !== 'function') {
          return;
        }
        if (index === 0 && typeof onPrimaryAck === 'function') {
          ref.put(null, (ack) => onPrimaryAck(ack, source));
        } else {
          ref.put(null);
        }
      });
    }

    const folderList = document.getElementById('folders');
    const noteList = document.getElementById('notes');
    const newFolderInput = document.getElementById('new-folder');
    const showFolderInputButton = document.getElementById('show-folder-input');
    const newNoteButton = document.getElementById('new-note-button');
    const noteSearchInput = document.getElementById('note-search');
    const noteTitleEl = document.getElementById('note-title');
    const noteContentEl = document.getElementById('note-content');
    const noteMetaEl = document.getElementById('note-meta');
    const emptyStateEl = document.getElementById('empty-state');
    const editorWrapperEl = document.getElementById('editor-wrapper');
    const slashMenuEl = document.getElementById('slash-menu');
    const slashOptionsEl = document.getElementById('slash-options');
    const insertImageButton = document.getElementById('insert-image-button');
    const imageUploadInput = document.getElementById('image-upload-input');
    const sidebarToggleButton = document.getElementById('sidebar-toggle');
    const sidebarBackdropEl = document.getElementById('mobile-sidebar-backdrop');
    const notesSidebarEl = document.getElementById('notes-sidebar');
    const navbarEl = document.querySelector('.navbar');
    const rootEl = document.documentElement;
    const bodyEl = document.body;
    const defaultEmptyMessage = emptyStateEl.innerHTML;
    const MOBILE_BREAKPOINT = 900;
    const DEFAULT_FOLDER_NAME = 'Quick Notes';
    const DEFAULT_FOLDER_ID = 'default-quick-notes';

    let currentFolder = null;
    let currentNoteId = null;
    let currentNoteRef = null;
    let suppressContentUpdate = false;
    let saveTimer = null;
    let slashActive = false;
    let slashTriggerRange = null;
    let filteredSlashOptions = [];
    let activeSlashIndex = 0;
    let defaultFolderSeeded = false;

    const folderElements = new Map();
    const folderCache = new Map();
    const noteElements = new Map();
    const noteCache = new Map();

    const slashOptionData = [
      { id: 'text', label: 'Text', description: 'Start with plain paragraphs', action: () => applyBlock('paragraph') },
      { id: 'heading1', label: 'Heading 1', description: 'Large section title', action: () => applyBlock('h1') },
      { id: 'heading2', label: 'Heading 2', description: 'Medium section title', action: () => applyBlock('h2') },
      { id: 'todo', label: 'To-do', description: 'Track tasks with checkboxes', action: () => applyBlock('todo') },
      { id: 'bulleted', label: 'Bulleted list', description: 'Create a bullet list', action: () => applyCommand('insertUnorderedList') },
      { id: 'numbered', label: 'Numbered list', description: 'Create a numbered list', action: () => applyCommand('insertOrderedList') },
      { id: 'quote', label: 'Quote', description: 'Add a quote block', action: () => applyBlock('quote') },
      { id: 'code', label: 'Code', description: 'Insert a code snippet', action: () => applyBlock('code') },
      { id: 'image', label: 'Image', description: 'Upload and embed an image', action: () => triggerImageUpload() },
      { id: 'divider', label: 'Divider', description: 'Visually separate sections', action: () => applyBlock('divider') }
    ];

    function updateNavbarHeight() {
      if (navbarEl) {
        rootEl.style.setProperty('--notes-navbar-height', `${navbarEl.offsetHeight}px`);
      }
    }

    function setSidebarExpanded(expanded) {
      bodyEl.classList.toggle('notes-sidebar-open', expanded);
      if (sidebarToggleButton) {
        sidebarToggleButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        sidebarToggleButton.setAttribute('aria-label', expanded ? 'Hide workspace' : 'Show workspace');
      }
      if (sidebarBackdropEl) {
        sidebarBackdropEl.setAttribute('aria-hidden', expanded ? 'false' : 'true');
      }
      if (notesSidebarEl) {
        const shouldHide = !expanded && window.innerWidth <= MOBILE_BREAKPOINT;
        notesSidebarEl.setAttribute('aria-hidden', shouldHide ? 'true' : 'false');
      }
    }

    function toggleSidebar() {
      const expanded = !bodyEl.classList.contains('notes-sidebar-open');
      setSidebarExpanded(expanded);
    }

    function closeSidebarForMobile() {
      if (window.innerWidth <= MOBILE_BREAKPOINT) {
        setSidebarExpanded(false);
      }
    }

    updateNavbarHeight();
    setSidebarExpanded(false);

    if (sidebarToggleButton) {
      sidebarToggleButton.addEventListener('click', () => {
        toggleSidebar();
      });
    }

    if (sidebarBackdropEl) {
      sidebarBackdropEl.addEventListener('click', () => {
        setSidebarExpanded(false);
      });
    }

    window.addEventListener('resize', () => {
      updateNavbarHeight();
      if (window.innerWidth > MOBILE_BREAKPOINT) {
        setSidebarExpanded(false);
      } else {
        setSidebarExpanded(bodyEl.classList.contains('notes-sidebar-open'));
      }
    });

    window.addEventListener('orientationchange', () => {
      updateNavbarHeight();
      if (window.innerWidth > MOBILE_BREAKPOINT) {
        setSidebarExpanded(false);
      } else {
        setSidebarExpanded(bodyEl.classList.contains('notes-sidebar-open'));
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && bodyEl.classList.contains('notes-sidebar-open')) {
        setSidebarExpanded(false);
      }
    });

    showFolderInputButton.addEventListener('click', () => {
      newFolderInput.classList.toggle('hidden');
      if (!newFolderInput.classList.contains('hidden')) {
        newFolderInput.focus();
      }
    });

    newFolderInput.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        event.target.value = '';
        event.target.classList.add('hidden');
        return;
      }
      if (event.key === 'Enter') {
        const name = event.target.value.trim();
        if (name) {
          const id = createFolder(name);
          selectFolder(id);
        }
        event.target.value = '';
        event.target.classList.add('hidden');
      }
    });

    function normalizeFolderName(name) {
      return (name || '').trim().toLowerCase();
    }

    function findFolderByNormalizedName(normalizedName) {
      for (const [id, folder] of folderCache.entries()) {
        if (folder.normalizedName === normalizedName) {
          return id;
        }
      }
      return null;
    }

    function mirrorFolderToPrimary(id, folder) {
      if (isStubSource(primaryFolderSource)) {
        return;
      }
      const payload = {};
      if (typeof folder.name === 'string') payload.name = folder.name;
      if (typeof folder.createdAt === 'number') payload.createdAt = folder.createdAt;
      if (typeof folder.updatedAt === 'number') payload.updatedAt = folder.updatedAt;
      if (Object.keys(payload).length === 0) {
        return;
      }
      primaryFolderSource.get(id).put(payload);
    }

    function handleFolderUpdate(folder, id, source) {
      if (!id) {
        return;
      }

      if (!folder) {
        const knownSource = folderSourceRefs.get(id);
        if (source === primaryFolderSource || !knownSource || knownSource === source) {
          const li = folderElements.get(id);
          if (li) {
            li.remove();
            folderElements.delete(id);
          }
          folderCache.delete(id);
          folderSourceRefs.delete(id);
          if (currentFolder === id) {
            currentFolder = null;
            newNoteButton.disabled = true;
            clearNotesSelection();
          }
        }
        return;
      }

      if (folder._) delete folder._;
      const name = folder.name?.trim() || 'Untitled Space';
      const normalizedName = normalizeFolderName(name);
      if (normalizedName === normalizeFolderName(DEFAULT_FOLDER_NAME)) {
        defaultFolderSeeded = true;
      }
      folderCache.set(id, {
        ...folder,
        id,
        name,
        normalizedName
      });
      const existingSource = folderSourceRefs.get(id);
      const shouldOverwriteSource = !existingSource || source === primaryFolderSource || existingSource === source;
      if (shouldOverwriteSource) {
        folderSourceRefs.set(id, source);
      }

      if (source !== primaryFolderSource && existingSource !== primaryFolderSource) {
        mirrorFolderToPrimary(id, folder);
      }

      let li = folderElements.get(id);
      if (!li) {
        li = createFolderElement(id);
        folderList.appendChild(li);
        folderElements.set(id, li);
      }
      li.querySelector('.folder-name').textContent = name;
      li.classList.toggle('active', currentFolder === id);
      if (!currentFolder) {
        selectFolder(id);
      }
    }

    folderSources.forEach((source) => {
      if (!source || typeof source.map !== 'function') {
        return;
      }
      const mapped = source.map();
      if (mapped && typeof mapped.on === 'function') {
        mapped.on((folder, id) => handleFolderUpdate(folder, id, source));
      }
    });

    let pendingFolderSnapshots = 0;

    function registerFolderSnapshot(source) {
      if (!source || typeof source.once !== 'function') {
        return;
      }
      pendingFolderSnapshots += 1;
      source.once((snapshot) => {
        const keys = Object.keys(snapshot || {}).filter((key) => key !== '_');
        if (keys.length > 0) {
          defaultFolderSeeded = true;
        }
        pendingFolderSnapshots -= 1;
        if (pendingFolderSnapshots === 0) {
          maybeSeedDefaultFolder();
        }
      });
    }

    function maybeSeedDefaultFolder() {
      if (defaultFolderSeeded) {
        return;
      }
      if (folderElements.size > 0) {
        defaultFolderSeeded = true;
        return;
      }
      const normalizedDefaultName = normalizeFolderName(DEFAULT_FOLDER_NAME);
      const existingDefaultId = findFolderByNormalizedName(normalizedDefaultName);
      if (existingDefaultId) {
        defaultFolderSeeded = true;
        if (!currentFolder) {
          selectFolder(existingDefaultId);
        }
        return;
      }
      setTimeout(() => {
        // Allow time for peers to sync existing folders so we do not double-create the default space.
        if (!defaultFolderSeeded && !findFolderByNormalizedName(normalizedDefaultName)) {
          seedDefaultFolder();
        }
      }, 750);
    }

    folderSources.forEach(registerFolderSnapshot);
    if (pendingFolderSnapshots === 0) {
      maybeSeedDefaultFolder();
    }

    function seedDefaultFolder() {
      if (defaultFolderSeeded) {
        return;
      }
      const normalizedDefaultName = normalizeFolderName(DEFAULT_FOLDER_NAME);
      const existingDefaultId = findFolderByNormalizedName(normalizedDefaultName);
      if (existingDefaultId) {
        defaultFolderSeeded = true;
        selectFolder(existingDefaultId);
        return;
      }
      defaultFolderSeeded = true;
      const id = createFolder(DEFAULT_FOLDER_NAME, DEFAULT_FOLDER_ID);
      selectFolder(id);
    }

    function createFolder(name, id = generateId()) {
      defaultFolderSeeded = true;
      const now = Date.now();
      const payload = {
        name: name || 'Untitled Space',
        createdAt: now,
        updatedAt: now
      };
      const normalizedName = normalizeFolderName(payload.name);
      putToSources(folderSources, id, payload, {
        onPrimaryAck: (ack) => {
          if (ack && ack.err) {
            console.error('Failed to create space', ack.err);
            flashEmptyState('Unable to create a space right now. Try again.');
          }
        }
      });
      folderSourceRefs.set(id, primaryFolderSource);
      folderCache.set(id, {
        ...payload,
        id,
        normalizedName
      });
      return id;
    }

    function createFolderElement(id) {
      const li = document.createElement('li');
      li.className = 'folder-item';
      li.tabIndex = 0;

      const icon = document.createElement('span');
      icon.className = 'folder-icon';
      icon.textContent = 'üìÅ';

      const nameEl = document.createElement('span');
      nameEl.className = 'folder-name editable';
      nameEl.textContent = 'Untitled Space';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'icon-button subtle';
      deleteBtn.innerHTML = 'üóë';
      deleteBtn.title = 'Delete space';
      deleteBtn.setAttribute('aria-label', 'Delete space');

      const content = document.createElement('div');
      content.className = 'folder-content';
      content.appendChild(icon);
      content.appendChild(nameEl);

      li.appendChild(content);
      li.appendChild(deleteBtn);

      li.addEventListener('click', () => selectFolder(id));
      li.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          selectFolder(id);
        }
      });

      deleteBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        if (confirm('Delete this space and its notes?')) {
          removeFromSources(folderSources, id, {
            onPrimaryAck: (ack) => {
              if (ack && ack.err) {
                console.error('Failed to delete space', ack.err);
              }
            }
          });
          folderSourceRefs.delete(id);
          removeNotesInFolder(id);
        }
      });

      nameEl.addEventListener('dblclick', (event) => {
        event.stopPropagation();
        enableEdit(nameEl, (value) => {
          const updated = value.trim() || 'Untitled Space';
          putToSources(folderSources, id, { name: updated, updatedAt: Date.now() });
        });
      });

      return li;
    }

    function selectFolder(id) {
      currentFolder = id;
      newNoteButton.disabled = false;
      folderElements.forEach((element, folderId) => {
        if (folderId === id) {
          element.classList.add('active');
        } else {
          element.classList.remove('active');
        }
      });
      filterNotes();
      if (currentNoteId && noteCache.get(currentNoteId)?.folder !== id) {
        closeEditor();
      }
    }

    function ensureFolderSelected() {
      if (currentFolder) {
        return currentFolder;
      }
      const iterator = folderElements.keys();
      const first = iterator.next();
      if (!first.done) {
        selectFolder(first.value);
        return first.value;
      }
      const id = createFolder(DEFAULT_FOLDER_NAME, DEFAULT_FOLDER_ID);
      selectFolder(id);
      return id;
    }

    function removeNotesInFolder(folderId) {
      noteCache.forEach((note, id) => {
        if (note.folder === folderId) {
          removeFromSources(noteSources, id, {
            onPrimaryAck: (ack) => {
              if (ack && ack.err) {
                console.error('Failed to delete note', ack.err);
              }
            }
          });
          noteSourceRefs.delete(id);
        }
      });
    }

    newNoteButton.addEventListener('click', () => {
      const activeFolder = ensureFolderSelected();
      if (!activeFolder) {
        return;
      }
      const id = generateId();
      const now = Date.now();
      const payload = {
        title: 'Untitled',
        folder: activeFolder,
        content: '',
        createdAt: now,
        updatedAt: now
      };
      putToSources(noteSources, id, payload, {
        onPrimaryAck: (ack) => {
          if (ack && ack.err) {
            console.error('Failed to create note', ack.err);
            return;
          }
          openNote(id);
          setTimeout(() => noteTitleEl.focus(), 120);
        }
      });
      noteSourceRefs.set(id, primaryNoteSource);
    });

    noteSearchInput.addEventListener('input', () => {
      filterNotes();
    });

    function mirrorNoteToPrimary(id, note) {
      if (isStubSource(primaryNoteSource)) {
        return;
      }
      const payload = {};
      if (typeof note.title === 'string') payload.title = note.title;
      if (typeof note.folder === 'string') payload.folder = note.folder;
      if (typeof note.createdAt === 'number') payload.createdAt = note.createdAt;
      if (typeof note.updatedAt === 'number') payload.updatedAt = note.updatedAt;
      if (Object.keys(payload).length > 0) {
        primaryNoteSource.get(id).put(payload);
      }
      if (typeof note.content === 'string') {
        primaryNoteSource.get(id).get('content').put(note.content);
      }
    }

    function handleNoteRemoval(id, source) {
      const knownSource = noteSourceRefs.get(id);
      if (source === primaryNoteSource || !knownSource || knownSource === source) {
        const li = noteElements.get(id);
        if (li) {
          li.remove();
          noteElements.delete(id);
        }
        noteCache.delete(id);
        noteSourceRefs.delete(id);
        if (currentNoteId === id) {
          closeEditor();
        }
      }
    }

    function handleNoteUpdate(note, id, source) {
      if (!id) {
        return;
      }
      if (!note) {
        handleNoteRemoval(id, source);
        return;
      }
      if (note._) delete note._;
      const cached = noteCache.get(id) || { id };
      const merged = { ...cached, ...note, id };
      noteCache.set(id, merged);
      const existingSource = noteSourceRefs.get(id);
      const shouldOverwriteSource = !existingSource || source === primaryNoteSource || existingSource === source;
      if (shouldOverwriteSource) {
        noteSourceRefs.set(id, source);
      }
      if (source !== primaryNoteSource && existingSource !== primaryNoteSource) {
        mirrorNoteToPrimary(id, merged);
      }
      ensureNoteListItem(id, merged);
      if (currentNoteId === id) {
        updateEditorMeta(merged);
      }
      filterNotes();
    }

    noteSources.forEach((source) => {
      if (!source || typeof source.map !== 'function') {
        return;
      }
      const mapped = source.map();
      if (mapped && typeof mapped.on === 'function') {
        mapped.on((note, id) => handleNoteUpdate(note, id, source));
      }
    });

    function ensureNoteListItem(id, note) {
      let li = noteElements.get(id);
      if (!li) {
        li = document.createElement('li');
        li.className = 'note-item';
        li.tabIndex = 0;

        const content = document.createElement('div');
        content.className = 'note-item-content';

        const title = document.createElement('div');
        title.className = 'note-item-title editable';
        content.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'note-item-meta';
        content.appendChild(meta);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'icon-button subtle';
        deleteBtn.innerHTML = 'üóë';
        deleteBtn.title = 'Delete note';
        deleteBtn.setAttribute('aria-label', 'Delete note');

        li.appendChild(content);
        li.appendChild(deleteBtn);

        li.addEventListener('click', () => openNote(id));
        li.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            openNote(id);
          }
        });

        deleteBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          if (confirm('Delete this note?')) {
            removeFromSources(noteSources, id, {
              onPrimaryAck: (ack) => {
                if (ack && ack.err) {
                  console.error('Failed to delete note', ack.err);
                }
              }
            });
            noteSourceRefs.delete(id);
          }
        });

        title.addEventListener('dblclick', (event) => {
          event.stopPropagation();
          enableEdit(title, (value) => {
            const updated = value.trim() || 'Untitled';
            putToSources(noteSources, id, { title: updated, updatedAt: Date.now() });
          });
        });

        noteElements.set(id, li);
        noteList.appendChild(li);
      }

      const titleEl = li.querySelector('.note-item-title');
      const metaEl = li.querySelector('.note-item-meta');
      titleEl.textContent = note.title?.trim() || 'Untitled';
      metaEl.textContent = formatListMeta(note);
      li.dataset.folder = note.folder || '';
      li.dataset.title = titleEl.textContent.toLowerCase();
      li.dataset.contentPreview = getContentPreview(note.content || '');
      li.classList.toggle('active', currentNoteId === id);
    }

    function filterNotes() {
      const query = noteSearchInput.value.trim().toLowerCase();
      noteElements.forEach((li, id) => {
        const note = noteCache.get(id);
        const matchesFolder = currentFolder && note?.folder === currentFolder;
        const matchesQuery = !query || li.dataset.title.includes(query) || li.dataset.contentPreview.includes(query);
        li.classList.toggle('hidden', !(matchesFolder && matchesQuery));
      });
      noteList.classList.toggle('empty', !currentFolder);
    }

    function openNote(id) {
      const data = noteCache.get(id);
      closeSidebarForMobile();
      if (data) {
        renderActiveNote(data);
        attachNoteListener(id);
        noteContentEl.focus();
        return;
      }
      currentNoteId = id;
      const source = noteSourceRefs.get(id) || primaryNoteSource;
      const ref = source && typeof source.get === 'function' ? source.get(id) : null;
      if (!ref || typeof ref.once !== 'function') {
        return;
      }
      ref.once((note) => {
        if (!note) {
          return;
        }
        if (note._) delete note._;
        const merged = { ...(noteCache.get(id) || {}), ...note, id };
        noteCache.set(id, merged);
        noteSourceRefs.set(id, source);
        renderActiveNote(merged);
        attachNoteListener(id);
        noteContentEl.focus();
      });
    }

    function renderActiveNote(note) {
      currentNoteId = note.id;
      noteElements.forEach((li, noteId) => {
        li.classList.toggle('active', noteId === note.id);
      });
      emptyStateEl.classList.add('hidden');
      editorWrapperEl.classList.remove('hidden');
      noteTitleEl.textContent = note.title || 'Untitled';
      if (!suppressContentUpdate) {
        noteContentEl.innerHTML = note.content || '';
      }
      updateEditorMeta(note);
    }

    function attachNoteListener(id) {
      if (currentNoteRef && currentNoteRef.off) {
        currentNoteRef.off();
      }
      const source = noteSourceRefs.get(id) || primaryNoteSource;
      const ref = source && typeof source.get === 'function' ? source.get(id) : null;
      if (!ref || typeof ref.on !== 'function') {
        currentNoteRef = null;
        return;
      }
      currentNoteRef = ref;
      currentNoteRef.on((note) => {
        if (!note) {
          closeEditor();
          return;
        }
        if (note._) delete note._;
        handleNoteUpdate(note, id, source);
        const merged = noteCache.get(id) || { id };
        if (document.activeElement !== noteTitleEl) {
          noteTitleEl.textContent = merged.title || 'Untitled';
        }
        if (!suppressContentUpdate) {
          noteContentEl.innerHTML = merged.content || '';
        }
        updateEditorMeta(merged);
        ensureNoteListItem(id, merged);
        filterNotes();
      });
    }

    function closeEditor() {
      currentNoteId = null;
      if (currentNoteRef && currentNoteRef.off) {
        currentNoteRef.off();
        currentNoteRef = null;
      }
      editorWrapperEl.classList.add('hidden');
      emptyStateEl.classList.remove('hidden');
      emptyStateEl.innerHTML = defaultEmptyMessage;
      noteTitleEl.textContent = '';
      noteContentEl.innerHTML = '';
      noteMetaEl.textContent = '';
      hideSlashMenu();
      noteElements.forEach((li) => li.classList.remove('active'));
    }

    function clearNotesSelection() {
      closeEditor();
      noteElements.forEach((li) => li.classList.add('hidden'));
      noteList.classList.add('empty');
    }

    function updateEditorMeta(note) {
      if (!note) {
        noteMetaEl.textContent = '';
        return;
      }
      const updatedAt = note.updatedAt || note.createdAt;
      noteMetaEl.textContent = updatedAt ? `Last edited ${formatRelativeTime(updatedAt)}` : '';
    }

    function formatListMeta(note) {
      if (!note) {
        return '';
      }
      const updatedAt = note.updatedAt || note.createdAt;
      const relative = updatedAt ? formatRelativeTime(updatedAt) : 'just now';
      return `Edited ${relative}`;
    }

    function formatRelativeTime(timestamp) {
      if (!timestamp) {
        return 'just now';
      }
      const diff = Date.now() - timestamp;
      const seconds = Math.floor(diff / 1000);
      if (seconds < 60) {
        return 'just now';
      }
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) {
        return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
      }
      const hours = Math.floor(minutes / 60);
      if (hours < 24) {
        return `${hours} hour${hours === 1 ? '' : 's'} ago`;
      }
      const days = Math.floor(hours / 24);
      if (days < 7) {
        return `${days} day${days === 1 ? '' : 's'} ago`;
      }
      const weeks = Math.floor(days / 7);
      if (weeks < 4) {
        return `${weeks} week${weeks === 1 ? '' : 's'} ago`;
      }
      const date = new Date(timestamp);
      return date.toLocaleDateString();
    }

    function getContentPreview(html) {
      const div = document.createElement('div');
      div.innerHTML = html;
      return div.textContent.trim().toLowerCase().slice(0, 120);
    }

    setInterval(() => {
      if (currentNoteId) {
        updateEditorMeta(noteCache.get(currentNoteId));
      }
      noteElements.forEach((li, id) => {
        const data = noteCache.get(id);
        if (!data) {
          return;
        }
        const metaEl = li.querySelector('.note-item-meta');
        metaEl.textContent = formatListMeta(data);
      });
    }, 60000);

    noteTitleEl.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        noteTitleEl.blur();
      }
    });

    noteTitleEl.addEventListener('blur', () => {
      if (!currentNoteId) {
        return;
      }
      const value = noteTitleEl.textContent.trim() || 'Untitled';
      const cached = noteCache.get(currentNoteId) || { id: currentNoteId };
      const now = Date.now();
      cached.title = value;
      cached.updatedAt = now;
      noteCache.set(currentNoteId, cached);
      putToSources(noteSources, currentNoteId, { title: value, updatedAt: now });
      ensureNoteListItem(currentNoteId, cached);
      filterNotes();
    });

    noteTitleEl.addEventListener('input', () => {
      if (!currentNoteId) {
        return;
      }
      const cached = noteCache.get(currentNoteId) || { id: currentNoteId };
      cached.title = noteTitleEl.textContent;
      noteCache.set(currentNoteId, cached);
      ensureNoteListItem(currentNoteId, cached);
      filterNotes();
    });

    noteContentEl.addEventListener('keydown', (event) => {
      if (event.key === '/' && !slashActive) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0 || !noteContentEl.contains(selection.anchorNode)) {
          return;
        }
        slashTriggerRange = selection.getRangeAt(0).cloneRange();
        requestAnimationFrame(() => {
          showSlashMenu();
          updateSlashMenu();
        });
        return;
      }

      if (!slashActive) {
        return;
      }

      if (event.key === 'Escape') {
        hideSlashMenu();
      } else if (event.key === 'ArrowDown') {
        event.preventDefault();
        if (filteredSlashOptions.length > 0) {
          activeSlashIndex = Math.min(activeSlashIndex + 1, filteredSlashOptions.length - 1);
          highlightSlashOption();
        }
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        if (filteredSlashOptions.length > 0) {
          activeSlashIndex = Math.max(activeSlashIndex - 1, 0);
          highlightSlashOption();
        }
      } else if (event.key === 'Enter') {
        event.preventDefault();
        const option = filteredSlashOptions[activeSlashIndex];
        if (option) {
          option.action();
          hideSlashMenu();
          scheduleContentSave();
        }
      }
    });

    noteContentEl.addEventListener('input', () => {
      if (slashActive) {
        updateSlashMenu();
      }
      scheduleContentSave();
    });

    noteContentEl.addEventListener('click', () => {
      if (slashActive) {
        hideSlashMenu();
      }
    });

    document.addEventListener('click', (event) => {
      if (slashActive && !slashMenuEl.contains(event.target) && event.target !== noteContentEl) {
        hideSlashMenu();
      }
    });

    document.addEventListener('selectionchange', () => {
      if (!slashActive) {
        return;
      }
      const selection = window.getSelection();
      if (!selection || !noteContentEl.contains(selection.anchorNode)) {
        hideSlashMenu();
      } else {
        positionSlashMenu();
      }
    });

    function scheduleContentSave() {
      if (!currentNoteId) {
        return;
      }
      if (saveTimer) {
        clearTimeout(saveTimer);
      }
      saveTimer = setTimeout(() => {
        const html = noteContentEl.innerHTML;
        suppressContentUpdate = true;
        const now = Date.now();
        putFieldToSources(noteSources, currentNoteId, 'content', html);
        putFieldToSources(noteSources, currentNoteId, 'updatedAt', now);
        const cached = noteCache.get(currentNoteId) || { id: currentNoteId };
        cached.content = html;
        cached.updatedAt = now;
        noteCache.set(currentNoteId, cached);
        ensureNoteListItem(currentNoteId, cached);
        updateEditorMeta(cached);
        filterNotes();
        setTimeout(() => {
          suppressContentUpdate = false;
        }, 150);
      }, 250);
    }

    document.querySelectorAll('.note-toolbar button').forEach((button) => {
      button.addEventListener('mousedown', (event) => {
        const { command, block } = button.dataset;
        if (!command && !block) {
          return;
        }
        event.preventDefault();
        noteContentEl.focus();
        if (command) {
          applyCommand(command, button.dataset.value || null);
        } else if (block) {
          applyBlock(block);
        }
        hideSlashMenu();
        scheduleContentSave();
      });
    });

    if (insertImageButton) {
      insertImageButton.addEventListener('click', () => {
        triggerImageUpload();
      });
    }

    if (imageUploadInput) {
      imageUploadInput.addEventListener('change', () => {
        const file = imageUploadInput.files && imageUploadInput.files[0];
        if (file) {
          insertImageFromFile(file);
        }
        imageUploadInput.value = '';
      });
    }

    function applyCommand(command, value = null) {
      consumeSlashCommand();
      document.execCommand(command, false, value);
    }

    function applyBlock(type) {
      consumeSlashCommand();
      switch (type) {
        case 'h1':
          document.execCommand('formatBlock', false, 'h1');
          break;
        case 'h2':
          document.execCommand('formatBlock', false, 'h2');
          break;
        case 'quote':
          document.execCommand('formatBlock', false, 'blockquote');
          break;
        case 'code':
          document.execCommand('formatBlock', false, 'pre');
          break;
        case 'todo':
          document.execCommand('insertHTML', false, '<div class="todo-line"><input type="checkbox"> <span>To-do</span></div>');
          break;
        case 'divider':
          document.execCommand('insertHTML', false, '<hr class="note-divider">');
          break;
        default:
          document.execCommand('formatBlock', false, 'p');
      }
    }

    function triggerImageUpload() {
      if (!currentNoteId) {
        return;
      }
      consumeSlashCommand();
      hideSlashMenu();
      noteContentEl.focus();
      if (imageUploadInput) {
        imageUploadInput.value = '';
        imageUploadInput.click();
      }
    }

    function insertImageFromFile(file) {
      if (!file || !currentNoteId) {
        return;
      }
      const targetNoteId = currentNoteId;
      const reader = new FileReader();
      reader.addEventListener('load', () => {
        if (typeof reader.result === 'string' && currentNoteId === targetNoteId) {
          insertImageElement(reader.result, file.name || '');
        }
      });
      reader.addEventListener('error', (event) => {
        console.error('Failed to read image for note', event);
      });
      reader.readAsDataURL(file);
    }

    function insertImageElement(dataUrl, fileName = '') {
      if (!dataUrl) {
        return;
      }
      const defaultAlt = fileName.replace(/\.[^/.]+$/, '') || 'Uploaded image';
      let altText = defaultAlt;
      if (typeof window.prompt === 'function') {
        const response = window.prompt('Describe the image for accessibility (alt text):', defaultAlt);
        if (response !== null) {
          const trimmed = response.trim();
          if (trimmed) {
            altText = trimmed;
          }
        }
      }
      const figure = document.createElement('figure');
      figure.className = 'note-image-block';
      const img = document.createElement('img');
      img.src = dataUrl;
      img.alt = altText;
      img.loading = 'lazy';
      img.decoding = 'async';
      figure.appendChild(img);
      const caption = document.createElement('figcaption');
      caption.className = 'note-image-caption';
      caption.setAttribute('contenteditable', 'true');
      caption.setAttribute('data-placeholder', 'Add caption (optional)');
      figure.appendChild(caption);
      placeNodeInEditor(figure);
      noteContentEl.focus();
      scheduleContentSave();
    }

    function placeNodeInEditor(node) {
      if (!node) {
        return;
      }
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0 || !noteContentEl.contains(selection.anchorNode)) {
        noteContentEl.appendChild(node);
        const paragraph = document.createElement('p');
        paragraph.appendChild(document.createElement('br'));
        noteContentEl.appendChild(paragraph);
        const range = document.createRange();
        range.setStart(paragraph, 0);
        range.collapse(true);
        if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
        }
        return;
      }
      const range = selection.getRangeAt(0);
      range.deleteContents();
      range.insertNode(node);
      range.setStartAfter(node);
      range.setEndAfter(node);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function consumeSlashCommand() {
      if (!slashTriggerRange) {
        return;
      }
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        slashTriggerRange = null;
        return;
      }
      const range = slashTriggerRange.cloneRange();
      range.setEnd(selection.getRangeAt(0).endContainer, selection.getRangeAt(0).endOffset);
      range.deleteContents();
      const collapsed = range.cloneRange();
      collapsed.collapse(true);
      selection.removeAllRanges();
      selection.addRange(collapsed);
      slashTriggerRange = null;
    }

    function showSlashMenu() {
      slashActive = true;
      filteredSlashOptions = [...slashOptionData];
      activeSlashIndex = 0;
      renderSlashOptions();
      positionSlashMenu();
      slashMenuEl.setAttribute('aria-hidden', 'false');
      slashMenuEl.classList.add('visible');
    }

    function hideSlashMenu() {
      slashActive = false;
      slashTriggerRange = null;
      slashMenuEl.classList.remove('visible');
      slashMenuEl.setAttribute('aria-hidden', 'true');
    }

    function updateSlashMenu() {
      if (!slashTriggerRange) {
        return;
      }
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        hideSlashMenu();
        return;
      }
      const range = slashTriggerRange.cloneRange();
      range.setEnd(selection.getRangeAt(0).endContainer, selection.getRangeAt(0).endOffset);
      const fragment = range.cloneContents();
      const div = document.createElement('div');
      div.appendChild(fragment);
      const text = div.textContent || '';
      if (!text.includes('/')) {
        hideSlashMenu();
        return;
      }
      const query = text.replace('/', '').trim().toLowerCase();
      filteredSlashOptions = slashOptionData.filter((option) => {
        if (!query) {
          return true;
        }
        return option.label.toLowerCase().includes(query) || option.description.toLowerCase().includes(query);
      });
      activeSlashIndex = 0;
      renderSlashOptions();
      positionSlashMenu();
    }

    function renderSlashOptions() {
      slashOptionsEl.innerHTML = '';
      if (filteredSlashOptions.length === 0) {
        const empty = document.createElement('li');
        empty.className = 'empty';
        empty.textContent = 'No blocks match your search';
        slashOptionsEl.appendChild(empty);
        return;
      }
      filteredSlashOptions.forEach((option, index) => {
        const li = document.createElement('li');
        li.classList.toggle('active', index === activeSlashIndex);
        const label = document.createElement('div');
        label.className = 'slash-option-label';
        label.textContent = option.label;
        const description = document.createElement('div');
        description.className = 'slash-option-description';
        description.textContent = option.description;
        li.appendChild(label);
        li.appendChild(description);
        li.addEventListener('mousedown', (event) => {
          event.preventDefault();
          option.action();
          hideSlashMenu();
          scheduleContentSave();
        });
        slashOptionsEl.appendChild(li);
      });
    }

    function highlightSlashOption() {
      Array.from(slashOptionsEl.children).forEach((li, index) => {
        li.classList.toggle('active', index === activeSlashIndex);
      });
    }

    function positionSlashMenu() {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) {
        return;
      }
      const range = selection.getRangeAt(0).cloneRange();
      range.collapse(true);
      let rect = range.getBoundingClientRect();
      if (!rect || (!rect.width && !rect.height)) {
        const fallback = slashTriggerRange?.getBoundingClientRect();
        if (fallback) {
          rect = fallback;
        }
      }
      if (!rect) {
        return;
      }
      const editorRect = noteContentEl.getBoundingClientRect();
      slashMenuEl.style.top = `${rect.bottom - editorRect.top + noteContentEl.scrollTop + 12}px`;
      slashMenuEl.style.left = `${rect.left - editorRect.left}px`;
    }

    function enableEdit(el, callback) {
      const original = el.textContent;
      el.setAttribute('contenteditable', 'true');
      el.focus();

      function finish(save) {
        el.removeAttribute('contenteditable');
        el.removeEventListener('blur', onBlur);
        el.removeEventListener('keydown', onKey);
        if (save) {
          const value = el.textContent.trim();
          callback(value || original);
        } else {
          el.textContent = original;
        }
      }

      function onBlur() {
        finish(true);
      }

      function onKey(event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          finish(true);
        }
        if (event.key === 'Escape') {
          event.preventDefault();
          finish(false);
        }
      }

      el.addEventListener('blur', onBlur);
      el.addEventListener('keydown', onKey);
    }

    function flashEmptyState(message) {
      emptyStateEl.classList.remove('hidden');
      emptyStateEl.innerHTML = `<h2>${message}</h2><p>Create a space to organize your notes like Notion.</p>`;
      setTimeout(() => {
        if (!currentNoteId) {
          emptyStateEl.innerHTML = defaultEmptyMessage;
        }
      }, 2500);
    }
  </script>
</body>
</html>
