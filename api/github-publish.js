const setCorsHeaders = (res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
};

function parseProvider(req) {
  const fromQuery = String(req?.query?.provider || '').trim().toLowerCase();
  if (fromQuery) {
    return fromQuery;
  }
  const fromBody = String(req?.body?.provider || '').trim().toLowerCase();
  if (fromBody) {
    return fromBody;
  }
  return 'github';
}

function resolveGithubRepo(body = {}) {
  const explicit = String(body.repo || '').trim();
  if (explicit && explicit.includes('/')) {
    return explicit;
  }

  const owner = String(body.owner || '').trim();
  if (owner && explicit) {
    return `${owner}/${explicit}`;
  }

  return explicit;
}

function validateGithubRequest(body) {
  const { token, content } = body || {};
  const repo = resolveGithubRepo(body);

  if (!token || typeof token !== 'string') {
    return 'A GitHub personal access token is required.';
  }

  if (!repo || typeof repo !== 'string' || !repo.includes('/')) {
    return 'Provide the repo as "owner/name".';
  }

  if (!content || typeof content !== 'string') {
    return 'Content is required to create or update the file.';
  }

  if (content.trim().length < 20 || !content.toLowerCase().includes('<html')) {
    return 'Provide full HTML content before committing to GitHub.';
  }

  return null;
}

function validateVercelRequest(body) {
  const { token, projectName, html } = body || {};

  if (!token || typeof token !== 'string') {
    return 'A Vercel token is required.';
  }

  if (!projectName || typeof projectName !== 'string') {
    return 'A project name is required.';
  }

  if (!html || typeof html !== 'string') {
    return 'HTML content is required for deployment.';
  }

  const trimmed = html.trim();
  if (!trimmed || trimmed.length < 20 || !trimmed.toLowerCase().includes('<html')) {
    return 'Provide complete HTML content before deploying to Vercel.';
  }

  return null;
}

async function fetchExistingFile({ token, repo, path, branch, fetchImpl }) {
  const url = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(path)}?ref=${branch}`;
  const response = await fetchImpl(url, {
    headers: { Authorization: `Bearer ${token}` }
  });

  if (response.status === 404) {
    return null;
  }

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`GitHub lookup error ${response.status}: ${errorText}`);
  }

  const data = await response.json();
  return data?.sha || null;
}

async function commitToGithub({ token, repo, path, branch, content, message, fetchImpl = globalThis.fetch }) {
  const sha = await fetchExistingFile({ token, repo, path, branch, fetchImpl });
  const url = `https://api.github.com/repos/${repo}/contents/${encodeURIComponent(path)}`;
  const body = {
    message: message || 'Publish from 3dvr OpenAI workbench',
    content: Buffer.from(content).toString('base64'),
    branch,
  };

  if (sha) {
    body.sha = sha;
  }

  const response = await fetchImpl(url, {
    method: 'PUT',
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`GitHub commit error ${response.status}: ${errorText}`);
  }

  const data = await response.json();
  return {
    path: data.content?.path || path,
    branch,
    htmlUrl: data.content?.html_url,
    commitSha: data.commit?.sha,
  };
}

async function createVercelDeployment({ token, projectName, html, fetchImpl = globalThis.fetch }) {
  const files = [
    { file: 'index.html', data: html },
    {
      file: 'README.md',
      data:
        '# Generated by 3dvr OpenAI Workbench\n\n'
        + 'This site was published directly from a chat response.\n'
    }
  ];

  const payload = {
    name: projectName.trim().toLowerCase().replace(/[^a-z0-9-]/gi, '-'),
    files,
    projectSettings: {
      framework: null
    },
    target: 'production'
  };

  const response = await fetchImpl('https://api.vercel.com/v13/deployments', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
  });

  if (!response.ok) {
    const errorText = await response.text();
    const status = response.status;
    throw new Error(`Vercel error ${status}: ${errorText || 'Unknown error'}`);
  }

  const data = await response.json();
  return {
    id: data.id,
    url: data.url ? `https://${data.url}` : undefined,
    inspectUrl: data.inspectUrl
  };
}

export function createGithubPublishHandler(options = {}) {
  const { fetchImpl = globalThis.fetch } = options;

  return async function handler(req, res) {
    setCorsHeaders(res);

    if (req.method === 'OPTIONS') {
      return res.status(200).end();
    }

    if (req.method !== 'POST') {
      return res.status(405).json({ error: 'Method Not Allowed' });
    }

    const body = req.body || {};
    const provider = parseProvider(req);

    if (provider === 'vercel') {
      const validationError = validateVercelRequest(body);
      if (validationError) {
        return res.status(400).json({ error: validationError });
      }

      try {
        const result = await createVercelDeployment({
          token: body.token,
          projectName: body.projectName,
          html: body.html,
          fetchImpl
        });

        return res.status(200).json({
          ...result,
          projectName: body.projectName,
          createdAt: Date.now()
        });
      } catch (err) {
        return res.status(500).json({ error: err.message || 'Unexpected Vercel deployment error.' });
      }
    }

    const validationError = validateGithubRequest(body);
    if (validationError) {
      return res.status(400).json({ error: validationError });
    }

    const branch = (body.branch || 'main').trim();
    const path = (body.path || 'index.html').replace(/^\/+/, '');
    const resolvedRepo = resolveGithubRepo(body);

    try {
      const result = await commitToGithub({
        token: body.token,
        repo: resolvedRepo,
        path,
        branch,
        content: body.content,
        message: body.message,
        fetchImpl,
      });

      return res.status(200).json({
        ...result,
        repo: resolvedRepo,
        message: body.message || 'Publish from 3dvr OpenAI workbench',
        createdAt: Date.now(),
      });
    } catch (err) {
      return res.status(500).json({ error: err.message || 'Unexpected GitHub publish error.' });
    }
  };
}

const handler = createGithubPublishHandler();
export default handler;
