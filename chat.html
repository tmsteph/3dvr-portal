<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3DVR - Group Chat</title>
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <script src="score.js"></script>
  <link rel="stylesheet" href="styles/global.css">
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      background: radial-gradient(circle at top, #334155, #0f172a 55%);
      color: #e2e8f0;
      min-height: 100vh;
      margin: 0;
      padding: 40px 20px 32px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    body::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(120% 120% at 0% 0%, rgba(14, 165, 233, 0.25), transparent 60%),
        radial-gradient(120% 120% at 100% 0%, rgba(59, 130, 246, 0.2), transparent 65%),
        radial-gradient(120% 120% at 100% 100%, rgba(16, 185, 129, 0.25), transparent 55%);
      pointer-events: none;
      z-index: 0;
    }

    body > * {
      position: relative;
      z-index: 1;
    }

    .top-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 28px;
      width: 100%;
      max-width: 1100px;
    }

    .top-buttons a {
      background: rgba(148, 163, 184, 0.15);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 999px;
      padding: 10px 18px;
      color: #e2e8f0;
      text-decoration: none;
      font-weight: 500;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .top-buttons a:hover {
      transform: translateY(-1px);
      border-color: rgba(148, 163, 184, 0.5);
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.2);
    }

    header {
      text-align: center;
      margin-bottom: 28px;
      max-width: 720px;
    }

    header h1 {
      font-size: 2.75rem;
      margin: 0;
      letter-spacing: -0.02em;
    }

    header p {
      color: #cbd5f5;
      font-size: 1.1rem;
      margin-top: 12px;
    }

    header strong {
      color: #38bdf8;
    }

    .chat-layout {
      display: grid;
      grid-template-columns: 320px minmax(0, 1fr);
      gap: 24px;
      width: 100%;
      max-width: 1100px;
      flex: 1;
    }

    .chat-sidebar {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .panel-card {
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.9));
      border-radius: 18px;
      padding: 20px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    #notification-settings {
      text-align: left;
    }

    #notification-settings strong {
      display: block;
      font-size: 1rem;
      margin-bottom: 6px;
    }

    #notification-settings button {
      margin-top: 14px;
    }

    #notification-status {
      display: block;
      margin-top: 6px;
      color: #cbd5f5;
      font-size: 0.95rem;
    }

    #profile-mini {
      text-align: left;
    }

    #profile-mini strong {
      color: #38bdf8;
    }

    .chat-main {
      display: flex;
      flex-direction: column;
    }

    .chat-main-card {
      background: rgba(15, 23, 42, 0.8);
      border-radius: 22px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      flex: 1;
      box-shadow: 0 30px 60px rgba(15, 23, 42, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.25);
      backdrop-filter: blur(12px);
    }

    .chat-room-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 20px;
    }

    .chat-room-title {
      flex: 1 1 240px;
    }

    .chat-room-title h2 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
      color: #f8fafc;
    }

    .chat-room-title p {
      margin: 6px 0 0;
      color: rgba(226, 232, 240, 0.7);
      font-size: 0.95rem;
    }

    #room-select {
      flex: 1;
      text-align: left;
    }

    #room-select label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      color: #e2e8f0;
    }

    #room-select select {
      width: 100%;
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 1rem;
      background: rgba(15, 23, 42, 0.85);
      color: #f8fafc;
      border: 1px solid rgba(148, 163, 184, 0.35);
      appearance: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    #room-select select:focus {
      border-color: #38bdf8;
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
      outline: none;
    }

    #new-message {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
      padding-bottom: 16px;
      align-items: center;
      position: sticky;
      top: -24px;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.95) 55%, rgba(15, 23, 42, 0));
      backdrop-filter: blur(12px);
      z-index: 2;
    }

    input[type="text"],
    button,
    select {
      font-family: inherit;
    }

    input[type="text"] {
      flex: 1;
      padding: 14px 16px;
      border-radius: 14px;
      font-size: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.85);
      color: #f8fafc;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    input[type="text"]::placeholder {
      color: rgba(226, 232, 240, 0.6);
    }

    input[type="text"]:focus {
      border-color: #38bdf8;
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
      outline: none;
    }

    button {
      padding: 14px 20px;
      font-size: 1rem;
      border-radius: 14px;
      border: none;
      background: linear-gradient(135deg, #38bdf8, #22d3ee);
      color: #0f172a;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(34, 211, 238, 0.35);
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding-right: 6px;
    }

    #messages::-webkit-scrollbar {
      width: 6px;
    }

    #messages::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.4);
      border-radius: 999px;
    }

    .message {
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.12), rgba(14, 165, 233, 0.08));
      border-radius: 16px;
      padding: 16px 18px;
      margin-bottom: 12px;
      box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.3);
      color: #f8fafc;
      backdrop-filter: blur(6px);
      transition: transform 0.2s ease;
    }

    .message:hover {
      transform: translateY(-1px);
    }

    .message strong {
      color: #38bdf8;
    }

    .meta {
      font-size: 0.8rem;
      color: rgba(226, 232, 240, 0.7);
      margin-top: 6px;
    }

    footer {
      margin-top: 48px;
      font-size: 0.85rem;
      color: rgba(226, 232, 240, 0.7);
      text-align: center;
    }

    footer a {
      color: #38bdf8;
      text-decoration: none;
      font-weight: 500;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 1024px) {
      .chat-layout {
        grid-template-columns: 1fr;
      }

      .chat-sidebar {
        order: 2;
      }

      .chat-main {
        order: 1;
      }
    }

    @media (max-width: 640px) {
      body {
        padding: 32px 16px 24px;
      }

      .chat-main-card {
        padding: 20px;
      }

      #new-message {
        flex-direction: column;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>

<div class="top-buttons">
  <a href="index.html">üè† Portal Home</a>
  <a href="profile.html">üßë Profile</a>
  <a href="https://3dvr.tech/#subscribe" target="_blank">‚≠ê Subscribe</a>
  <a href="https://github.com/tmsteph/3dvr-portal" target="_blank">üöÄ Contribute on GitHub</a>
</div>

<header>
  <h1>Group Chat</h1>
  <p>üí¨ You earn <strong>+1 point</strong> for every message you send!</p>
</header>

<main class="chat-layout">
  <aside class="chat-sidebar">
    <div id="notification-settings" class="panel-card">
      <strong>üîî Chat notifications</strong>
      <span id="notification-status">Checking permissions‚Ä¶</span>
      <button id="notification-toggle" onclick="toggleNotifications()">Enable Notifications</button>
    </div>

    <div id="profile-mini" class="panel-card">
      <p><strong>Username:</strong> <span id="current-username">Loading...</span></p>
    </div>
  </aside>

  <section class="chat-main">
    <div class="chat-main-card">
      <div class="chat-room-header">
        <div class="chat-room-title">
          <h2>Live conversations</h2>
          <p>Switch rooms to jump between community spaces.</p>
        </div>
        <div id="room-select">
          <label for="room">Select room</label>
          <select id="room" onchange="changeRoom()">
            <option value="general">üåé General</option>
            <option value="ideas">üí° Ideas</option>
            <option value="support">üõü Support</option>
            <option value="random">üé≤ Random</option>
          </select>
        </div>
      </div>

      <div id="new-message">
        <input type="text" id="message-input" placeholder="Type your message..." />
        <button onclick="sendMessage()">Send</button>
      </div>

      <div id="messages"></div>
    </div>
  </section>
</main>

<footer>
  3DVR.Tech &copy; 2025 - Open Web for Everyone | Visit <a href="https://3dvr.tech">3DVR.Tech</a> | <a href="https://github.com/tmsteph/3dvr-portal">Contribute on GitHub</a>
</footer>

<script>
const gun = Gun([
  'https://gun-relay-3dvr.fly.dev/gun',          // üëà primary
]);
const portalRoot = gun.get('3dvr-portal');
const gunSupportsUser = typeof gun.user === 'function';
const portalUser = gunSupportsUser ? gun.user() : null;
const scoreManager = window.ScoreSystem && typeof window.ScoreSystem.getManager === 'function'
  ? window.ScoreSystem.getManager({
      gun: gunSupportsUser ? gun : null,
      user: portalUser,
      portalRoot
    })
  : null;
let currentRoom = 'general';
let chat = gun.get('3dvr-chat').get(currentRoom);

const notificationToggleButton = document.getElementById('notification-toggle');
const notificationStatusText = document.getElementById('notification-status');
const notificationsSupported = 'Notification' in window;
const notificationsPreferenceKey = 'chatNotificationsEnabled';
const notificationIconPath = '/icons/icon-192.png';
const notificationStateStorageKey = 'chatNotificationState';
const INITIAL_SYNC_GRACE_MS = 1500;
let notificationsEnabled = false;
let serviceWorkerRegistration = null;
let currentRoomStream = null;
const roomInitialSyncTimers = {};
const notifiedMessageIdsByRoom = {};
const notifiedMessageQueueByRoom = {};

const CHAT_USER_ROOT = '3dvr-users';
const CHAT_GUEST_ROOT = '3dvr-guests';

function safeGetStorage(key) {
  try {
    return localStorage.getItem(key) || '';
  } catch (error) {
    console.warn(`Unable to read ${key} from storage`, error);
    return '';
  }
}

function safeSetStorage(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch (error) {
    console.warn(`Unable to store ${key} in storage`, error);
  }
}

function safeRemoveStorage(key) {
  try {
    localStorage.removeItem(key);
  } catch (error) {
    console.warn(`Unable to remove ${key} from storage`, error);
  }
}

function resolveChatIdentity() {
  try {
    const signedIn = safeGetStorage('signedIn') === 'true';
    let guestId = '';

    if (!signedIn) {
      if (window.ScoreSystem && typeof window.ScoreSystem.ensureGuestIdentity === 'function') {
        guestId = window.ScoreSystem.ensureGuestIdentity() || '';
      }

      if (!guestId) {
        guestId = safeGetStorage('guestId').trim();
      }

      if (!guestId) {
        const legacyId = safeGetStorage('userId').trim();
        if (legacyId) {
          guestId = legacyId;
          safeSetStorage('guestId', guestId);
          safeRemoveStorage('userId');
        }
      }

      if (guestId) {
        safeSetStorage('guest', 'true');
        if (!safeGetStorage('guestDisplayName')) {
          safeSetStorage('guestDisplayName', 'Guest');
        }
        return {
          id: guestId,
          type: 'guest',
          profileRoot: CHAT_GUEST_ROOT,
          storageKey: 'guestId'
        };
      }
    }

    let storedUserId = safeGetStorage('userId').trim();
    if (!storedUserId) {
      const prefix = signedIn ? 'user' : 'guest';
      storedUserId = `${prefix}_${Math.random().toString(36).substr(2, 9)}`;
      safeSetStorage('userId', storedUserId);
    }

    return {
      id: storedUserId,
      type: signedIn ? 'user' : 'legacy',
      profileRoot: CHAT_USER_ROOT,
      storageKey: 'userId'
    };
  } catch (error) {
    console.warn('Failed to resolve chat identity', error);
  }

  const fallbackId = `user_${Math.random().toString(36).substr(2, 9)}`;
  return {
    id: fallbackId,
    type: 'legacy',
    profileRoot: CHAT_USER_ROOT,
    storageKey: 'userId'
  };
}

function fetchSenderUsername(senderId, handler) {
  if (typeof handler !== 'function') return;
  if (!senderId) {
    handler('');
    return;
  }

  const readGuestName = callback => {
    gun.get(CHAT_GUEST_ROOT).get(senderId).get('username').once(name => {
      const normalized = typeof name === 'string' ? name.trim() : '';
      callback(normalized);
    });
  };

  const readUserName = callback => {
    gun.get(CHAT_USER_ROOT).get(senderId).get('username').once(name => {
      const normalized = typeof name === 'string' ? name.trim() : '';
      callback(normalized);
    });
  };

  const looksLikeGuest = typeof senderId === 'string' && senderId.startsWith('guest_');
  const firstReader = looksLikeGuest ? readGuestName : readUserName;
  const fallbackReader = looksLikeGuest ? readUserName : readGuestName;

  firstReader(name => {
    if (name) {
      handler(name);
      return;
    }
    fallbackReader(fallbackName => {
      handler(fallbackName || '');
    });
  });
}

function loadNotificationState() {
  try {
    const raw = localStorage.getItem(notificationStateStorageKey);
    if (!raw) {
      return { rooms: {} };
    }

    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') {
      return { rooms: {} };
    }

    if (!parsed.rooms || typeof parsed.rooms !== 'object') {
      parsed.rooms = {};
    }

    Object.keys(parsed.rooms).forEach(room => {
      const roomState = parsed.rooms[room];
      if (!roomState || typeof roomState !== 'object') {
        parsed.rooms[room] = {
          lastSeenTimestamp: 0,
          lastSeenMessageIds: [],
          initialSync: true,
          initialSyncCutoff: 0
        };
        return;
      }

      if (typeof roomState.lastSeenTimestamp !== 'number' || !Number.isFinite(roomState.lastSeenTimestamp)) {
        roomState.lastSeenTimestamp = 0;
      }

      if (!Array.isArray(roomState.lastSeenMessageIds)) {
        roomState.lastSeenMessageIds = [];
      }

      roomState.initialSync = Boolean(roomState.initialSync);
      roomState.initialSyncCutoff = typeof roomState.initialSyncCutoff === 'number'
        ? roomState.initialSyncCutoff
        : 0;
    });

    return parsed;
  } catch (error) {
    console.warn('Unable to load notification state', error);
    return { rooms: {} };
  }
}

const notificationState = loadNotificationState();

function persistNotificationState() {
  try {
    localStorage.setItem(notificationStateStorageKey, JSON.stringify(notificationState));
  } catch (error) {
    console.warn('Failed to persist notification state', error);
  }
}

function getRoomNotificationState(room) {
  if (!notificationState.rooms || typeof notificationState.rooms !== 'object') {
    notificationState.rooms = {};
  }

  if (!notificationState.rooms[room]) {
    notificationState.rooms[room] = {
      lastSeenTimestamp: 0,
      lastSeenMessageIds: [],
      initialSync: true,
      initialSyncCutoff: 0
    };
  } else {
    const roomState = notificationState.rooms[room];
    if (typeof roomState.lastSeenTimestamp !== 'number' || !Number.isFinite(roomState.lastSeenTimestamp)) {
      roomState.lastSeenTimestamp = 0;
    }
    if (!Array.isArray(roomState.lastSeenMessageIds)) {
      roomState.lastSeenMessageIds = [];
    }
    if (typeof roomState.initialSync !== 'boolean') {
      roomState.initialSync = true;
    }
    if (typeof roomState.initialSyncCutoff !== 'number' || !Number.isFinite(roomState.initialSyncCutoff)) {
      roomState.initialSyncCutoff = 0;
    }
  }

  return notificationState.rooms[room];
}

function updateRoomStateWithMessage(roomState, createdAt, id) {
  if (!roomState) return;

  const timestamp = typeof createdAt === 'number' && Number.isFinite(createdAt)
    ? createdAt
    : 0;

  if (!timestamp) {
    if (id) {
      const ids = roomState.lastSeenMessageIds;
      if (!ids.includes(id)) {
        ids.push(id);
        if (ids.length > 10) {
          ids.splice(0, ids.length - 10);
        }
      }
    }
    return;
  }

  if (!roomState.lastSeenTimestamp || timestamp > roomState.lastSeenTimestamp) {
    roomState.lastSeenTimestamp = timestamp;
    roomState.lastSeenMessageIds = id ? [id] : [];
    return;
  }

  if (timestamp === roomState.lastSeenTimestamp && id) {
    const ids = roomState.lastSeenMessageIds;
    if (!ids.includes(id)) {
      ids.push(id);
      if (ids.length > 10) {
        ids.splice(0, ids.length - 10);
      }
    }
  }
}

function clearInitialSyncTimer(room) {
  const timer = roomInitialSyncTimers[room];
  if (timer) {
    clearTimeout(timer);
    delete roomInitialSyncTimers[room];
  }
}

function beginRoomNotificationSync(room) {
  const roomState = getRoomNotificationState(room);
  roomState.initialSync = true;
  roomState.initialSyncCutoff = Date.now();
  persistNotificationState();

  clearInitialSyncTimer(room);
  roomInitialSyncTimers[room] = setTimeout(() => {
    const state = getRoomNotificationState(room);
    state.initialSync = false;
    state.initialSyncCutoff = 0;
    if (!state.lastSeenTimestamp || state.lastSeenTimestamp < Date.now()) {
      state.lastSeenTimestamp = Math.max(state.lastSeenTimestamp || 0, Date.now());
      if (!Array.isArray(state.lastSeenMessageIds)) {
        state.lastSeenMessageIds = [];
      }
    }
    persistNotificationState();
  }, INITIAL_SYNC_GRACE_MS);
}

const MAX_TRACKED_NOTIFICATIONS = 200;

function hasMessageBeenNotified(room, id) {
  if (!id) return false;
  const set = notifiedMessageIdsByRoom[room];
  return set ? set.has(id) : false;
}

function markMessageNotified(room, id) {
  if (!id) return;

  if (!notifiedMessageIdsByRoom[room]) {
    notifiedMessageIdsByRoom[room] = new Set();
    notifiedMessageQueueByRoom[room] = [];
  }

  const set = notifiedMessageIdsByRoom[room];
  const queue = notifiedMessageQueueByRoom[room];

  if (set.has(id)) return;

  set.add(id);
  queue.push(id);

  if (queue.length > MAX_TRACKED_NOTIFICATIONS) {
    const oldest = queue.shift();
    if (oldest) {
      set.delete(oldest);
    }
  }
}

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', event => {
    if (event.data && event.data.type === 'notification-clicked') {
      window.focus();
    }
  });
}

const currentUsernameEl = document.getElementById('current-username');
let cachedUsername = '';

const chatIdentity = resolveChatIdentity();
const userId = chatIdentity.id;
const isGuestIdentity = chatIdentity.type === 'guest';
const chatProfile = gun.get(chatIdentity.profileRoot).get(userId);

// Auto import old chats into General (only runs if in General and no messages exist)
if (currentRoom === 'general') {
  gun.get('3dvr-chat').map().once((message, id) => {
    if (!message) return;
    chat.get(id).once(existing => {
      if (!existing) {
        chat.get(id).put(message);
        console.log('Imported old message:', id);
      }
    });
  });
}

const initialUsername = derivePreferredUsername();
applyUsernameToUI(initialUsername);

if (chatProfile && typeof chatProfile.get === 'function') {
  chatProfile.get('username').once(existingName => {
    const resolvedName = derivePreferredUsername(existingName);
    applyUsernameToUI(resolvedName);
    const normalizedExisting = typeof existingName === 'string' ? existingName.trim() : '';
    if (normalizedExisting !== resolvedName) {
      chatProfile.get('username').put(resolvedName);
    }
  });

  chatProfile.get('username').on(name => {
    const normalized = typeof name === 'string' ? name.trim() : '';
    if (!normalized) return;
    applyUsernameToUI(normalized);
  });
}

function applyUsernameToUI(name) {
  const normalized = typeof name === 'string' ? name.trim() : '';
  const finalName = normalized || 'Guest';
  cachedUsername = finalName;
  if (normalized) {
    if (isGuestIdentity) {
      safeSetStorage('guestDisplayName', normalized);
    } else {
      safeSetStorage('username', normalized);
    }
  } else {
    if (isGuestIdentity) {
      safeSetStorage('guestDisplayName', 'Guest');
    } else {
      safeRemoveStorage('username');
    }
  }
  if (!currentUsernameEl) return;
  currentUsernameEl.innerText = finalName;
}

function derivePreferredUsername(existingName) {
  const normalizedExisting = typeof existingName === 'string' ? existingName.trim() : '';
  const storedGuestName = isGuestIdentity ? safeGetStorage('guestDisplayName').trim() : '';
  const storedUsername = safeGetStorage('username').trim();

  if (isGuestIdentity && storedGuestName) {
    return storedGuestName;
  }

  if (!isGuestIdentity && storedUsername) {
    return storedUsername;
  }

  const aliasValue = safeGetStorage('alias').trim();
  const aliasName = aliasValue
    ? (aliasValue.includes('@') ? aliasValue.split('@')[0] : aliasValue)
    : '';

  if (aliasName && (!normalizedExisting || isGeneratedName(normalizedExisting))) {
    return aliasName;
  }

  if (normalizedExisting) return normalizedExisting;

  if (aliasName) return aliasName;

  if (isGuestIdentity && storedGuestName) {
    return storedGuestName;
  }

  const suffix = extractIdSuffix(userId);
  const baseLabel = 'Guest';
  return suffix ? `${baseLabel} ${suffix}` : baseLabel;
}

function extractIdSuffix(id) {
  if (!id) return '';
  const parts = id.split('_');
  const lastPart = parts[parts.length - 1] || '';
  return lastPart.slice(-4).toUpperCase();
}

function isGeneratedName(name) {
  if (!name) return false;
  const lower = name.toLowerCase();
  return lower === 'guest' ||
    lower.startsWith('guest ') ||
    lower.startsWith('guest_') ||
    lower === 'user' ||
    lower.startsWith('user ') ||
    lower.startsWith('user_');
}

function sendMessage() {
  const input = document.getElementById('message-input');
  const text = input.value.trim();
  if (!text) return;

  chat.set({
    text,
    sender: userId,
    username: cachedUsername,
    createdAt: Date.now()
  });

  input.value = '';

  if (scoreManager) {
    scoreManager.increment(1);
  }
}

const messages = {};

function resetNotifiedStateForRoom(room) {
  if (!room) return;
  const set = notifiedMessageIdsByRoom[room];
  const queue = notifiedMessageQueueByRoom[room];
  if (set) {
    set.clear();
  }
  if (queue) {
    queue.length = 0;
  }
}

function timeAgoOrFullDate(timestamp) {
  const now = Date.now();
  const diff = Math.floor((now - timestamp) / 1000);
  if (diff < 60) return `${diff}s ago`;
  const mins = Math.floor(diff / 60);
  if (mins < 60) return `${mins}m ago`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `${hrs}h ago`;
  const date = new Date(timestamp);
  return date.toLocaleString(undefined, { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' });
}

function displayMessages() {
  const messagesDiv = document.getElementById('messages');
  messagesDiv.innerHTML = '';

  const sorted = Object.entries(messages).sort(([, a], [, b]) => (b.createdAt || 0) - (a.createdAt || 0));
  for (const [id, message] of sorted) {
    const msgDiv = document.createElement('div');
    msgDiv.className = 'message';
    msgDiv.id = id;

    const username = (typeof message.username === 'string' ? message.username.trim() : '') ||
      (message.sender || 'Anonymous');
    const time = message.createdAt ? timeAgoOrFullDate(message.createdAt) : '';

    msgDiv.innerHTML = `<div><strong>${username}:</strong> ${message.text}</div><div class="meta">${time}</div>`;
    messagesDiv.appendChild(msgDiv);
  }
}

function loadRoom(roomName) {
  const messagesDiv = document.getElementById('messages');
  messagesDiv.innerHTML = '';
  Object.keys(messages).forEach(key => delete messages[key]);
  resetNotifiedStateForRoom(roomName);
  beginRoomNotificationSync(roomName);

  if (currentRoomStream && typeof currentRoomStream.off === 'function') {
    currentRoomStream.off();
  }

  chat = gun.get('3dvr-chat').get(roomName);
  const roomStream = chat.map();
  currentRoomStream = roomStream;

  roomStream.on((message, id) => {
    if (!message || messages[id]) return;

    if (message.sender) {
      const existingUsername = typeof message.username === 'string'
        ? message.username.trim()
        : '';
      if (existingUsername) {
        message.username = existingUsername;
        messages[id] = message;
        displayMessages();
        maybeNotifyNewMessage(message, id);
        return;
      }

      fetchSenderUsername(message.sender, resolvedName => {
        const finalName = resolvedName || message.sender;
        message.username = finalName;
        messages[id] = message;
        displayMessages();
        maybeNotifyNewMessage(message, id);
      });
    } else {
      messages[id] = message;
      displayMessages();
      maybeNotifyNewMessage(message, id);
    }
  });
}

function changeRoom() {
  currentRoom = document.getElementById('room').value;
  loadRoom(currentRoom);
}

loadRoom(currentRoom);

function initNotifications() {
  if (!notificationToggleButton || !notificationStatusText) return;

  if (!notificationsSupported) {
    notificationToggleButton.style.display = 'none';
    notificationStatusText.textContent = 'Notifications are not supported in this browser.';
    return;
  }

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistration().then(existingRegistration => {
      if (existingRegistration) {
        serviceWorkerRegistration = existingRegistration;
        return existingRegistration;
      }
      return navigator.serviceWorker.register('/service-worker.js', { scope: '/' })
        .then(registration => {
          serviceWorkerRegistration = registration;
          return registration;
        });
    }).catch(error => {
      console.error('Service worker registration failed for chat notifications', error);
    });
  }

  const savedPreference = localStorage.getItem(notificationsPreferenceKey) === 'true';
  if (savedPreference && Notification.permission === 'granted') {
    notificationsEnabled = true;
  }

  updateNotificationUI();
}

function updateNotificationUI() {
  if (!notificationToggleButton || !notificationStatusText) return;

  if (!notificationsSupported) {
    notificationToggleButton.style.display = 'none';
    notificationStatusText.textContent = 'Notifications are not supported in this browser.';
    return;
  }

  if (Notification.permission === 'denied') {
    notificationToggleButton.disabled = true;
    notificationStatusText.textContent = 'Notifications are blocked in your browser settings.';
    return;
  }

  notificationToggleButton.disabled = false;
  notificationToggleButton.textContent = notificationsEnabled ? 'Disable Notifications' : 'Enable Notifications';

  if (notificationsEnabled && Notification.permission === 'granted') {
    notificationStatusText.textContent = 'Notifications are on. We will alert you about new messages.';
  } else {
    notificationStatusText.textContent = 'Notifications are off. Click enable to stay updated.';
  }
}

function toggleNotifications() {
  if (!notificationsSupported) return;

  if (notificationsEnabled) {
    notificationsEnabled = false;
    localStorage.setItem(notificationsPreferenceKey, 'false');
    updateNotificationUI();
    return;
  }

  if (Notification.permission === 'granted') {
    notificationsEnabled = true;
    localStorage.setItem(notificationsPreferenceKey, 'true');
    updateNotificationUI();
    sendNotificationPreview();
    return;
  }

  Notification.requestPermission().then(permission => {
    notificationsEnabled = permission === 'granted';
    localStorage.setItem(notificationsPreferenceKey, notificationsEnabled ? 'true' : 'false');

    if (permission === 'denied') {
      notificationStatusText.textContent = 'Notifications are blocked in your browser settings.';
    }

    updateNotificationUI();

    if (permission === 'granted') {
      sendNotificationPreview();
    }
  });
}

async function attemptServiceWorkerNotification(registration, title, options) {
  if (!registration) return false;

  try {
    if (registration.active && typeof registration.active.postMessage === 'function') {
      registration.active.postMessage({
        type: 'show-notification',
        payload: { title, options }
      });
      return true;
    }

    if (typeof registration.showNotification === 'function') {
      await registration.showNotification(title, options);
      return true;
    }
  } catch (error) {
    console.error('Service worker notification attempt failed', error);
  }

  return false;
}

async function showChatNotification(title, options = {}, config = {}) {
  if (!notificationsEnabled || !notificationsSupported) return;
  if (!title || Notification.permission !== 'granted') return;

  const { requireHidden = true } = config;
  if (requireHidden && document.visibilityState === 'visible') return;

  const enrichedOptions = {
    ...options,
    icon: options.icon || notificationIconPath,
    badge: options.badge || notificationIconPath,
    timestamp: Date.now(),
    data: {
      ...options.data,
      url: options.data?.url || `/chat.html#${currentRoom}`,
      room: currentRoom
    }
  };

  const fallbackToPageNotification = () => {
    try {
      const notification = new Notification(title, enrichedOptions);
      setTimeout(() => notification.close(), 8000);
    } catch (error) {
      console.error('Unable to show notification', error);
    }
  };

  if (!('serviceWorker' in navigator)) {
    fallbackToPageNotification();
    return;
  }

  if (await attemptServiceWorkerNotification(serviceWorkerRegistration, title, enrichedOptions)) {
    return;
  }

  try {
    const registration = await navigator.serviceWorker.ready;
    serviceWorkerRegistration = registration;

    const success = await attemptServiceWorkerNotification(registration, title, enrichedOptions);
    if (!success) {
      fallbackToPageNotification();
    }
  } catch (error) {
    console.error('Service worker readiness error', error);
    fallbackToPageNotification();
  }
}

function sendNotificationPreview() {
  showChatNotification(
    'Chat notifications enabled',
    {
      body: 'We will let you know when someone posts a new message.',
      tag: 'chat-notification-preview',
      data: { messageId: 'preview' }
    },
    { requireHidden: false }
  );
}

function maybeNotifyNewMessage(message, id) {
  if (!message || message.sender === userId) return;

  const roomState = getRoomNotificationState(currentRoom);
  const cutoff = roomState.initialSyncCutoff || 0;
  const createdAt = typeof message.createdAt === 'number' && Number.isFinite(message.createdAt)
    ? message.createdAt
    : null;

  if (roomState.initialSync) {
    const isHistorical = createdAt !== null && cutoff && createdAt <= cutoff;
    if (isHistorical) {
      updateRoomStateWithMessage(roomState, createdAt, id);
      markMessageNotified(currentRoom, id);
      persistNotificationState();
      return;
    }

    if (!createdAt && cutoff && Date.now() - cutoff < INITIAL_SYNC_GRACE_MS) {
      markMessageNotified(currentRoom, id);
      return;
    }

    roomState.initialSync = false;
    roomState.initialSyncCutoff = 0;
    persistNotificationState();
  }

  if (hasMessageBeenNotified(currentRoom, id)) {
    return;
  }

  const effectiveTimestamp = createdAt !== null ? createdAt : Date.now();
  const lastTimestamp = roomState.lastSeenTimestamp || 0;
  const ids = Array.isArray(roomState.lastSeenMessageIds)
    ? roomState.lastSeenMessageIds
    : (roomState.lastSeenMessageIds = []);

  if (createdAt !== null) {
    if (effectiveTimestamp < lastTimestamp) {
      return;
    }

    if (effectiveTimestamp === lastTimestamp && ids.includes(id)) {
      return;
    }
  }

  const username = (typeof message.username === 'string' ? message.username.trim() : '') ||
    message.sender ||
    'Someone';

  const rawPreview = typeof message.text === 'string'
    ? message.text.trim()
    : String(message.text || '').trim();
  const notificationBody = rawPreview.length > 160 ? `${rawPreview.slice(0, 157)}...` : rawPreview;

  const title = `${username} in #${currentRoom}`;
  const options = {
    body: notificationBody || 'New message',
    tag: `${currentRoom}-${id}`,
    data: {
      messageId: id
    }
  };

  showChatNotification(title, options, { requireHidden: true });
  markMessageNotified(currentRoom, id);
  updateRoomStateWithMessage(roomState, effectiveTimestamp, id);
  persistNotificationState();
}

initNotifications();
</script>

</body>
</html>
