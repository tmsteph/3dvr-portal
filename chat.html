<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3DVR - Group Chat</title>
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="gun-init.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <script src="score.js"></script>
  <script src="/pwa-install.js" defer></script>
  <link rel="stylesheet" href="styles/global.css">
  <link rel="stylesheet" href="styles/chat.css">
  <link rel="stylesheet" href="/styles/install-banner.css">
  <link rel="manifest" href="/app-manifests/chat.webmanifest">
  <meta name="theme-color" content="#0e1116">
</head>
<body class="theme-dark chat-page">
  <a class="skip-link" href="#chatMain">Skip to chat</a>

  <a
    id="chat-floating-meta"
    class="chat-floating-meta"
    href="profile.html"
    aria-live="polite"
  >
    <span id="chat-floating-username" class="chat-floating-meta__name">Guest</span>
    <span class="chat-floating-meta__divider" aria-hidden="true">‚Ä¢</span>
    <span class="chat-floating-meta__score">
      <span class="sr-only">Score</span>
      <span id="chat-floating-score-value" aria-hidden="true">0</span>
    </span>
    <span class="sr-only">Open profile</span>
  </a>

  <div class="top-buttons" role="navigation" aria-label="3DVR quick links">
    <a href="index.html">üè† Portal Home</a>
    <a href="profile.html">üßë Profile</a>
    <a href="https://3dvr.tech/#subscribe" target="_blank" rel="noopener">‚≠ê Subscribe</a>
    <a href="https://github.com/tmsteph/3dvr-portal" target="_blank" rel="noopener">üöÄ Contribute on GitHub</a>
  </div>

  <div class="install-banner" data-install-banner hidden>
    <div class="install-banner__text">
      <p class="install-banner__title">Install Chat</p>
      <p class="install-banner__meta">Pin the community hub to your dock and stay connected offline.</p>
    </div>
    <button type="button" class="install-banner__action" data-install-button>Install app</button>
  </div>

  <main id="chatMain" class="chat-shell" aria-labelledby="chatTitle">
    <header class="chat-hero">
      <span class="chat-hero__eyebrow">Community Hub</span>
      <h1 id="chatTitle">Group Chat</h1>
      <p class="chat-hero__tagline">
        Sync with the 3DVR community, share quick wins, and keep projects moving without missing a beat.
      </p>
      <div class="chat-hero__actions">
        <a class="chat-hero__portal-link" href="index.html">‚Üê Back to Portal</a>
      </div>
      <div class="chat-hero__meta">
        <span class="chat-hero__reward">üí¨ Earn <strong>+1 point</strong> for every message you send.</span>
        <div
          id="chat-score"
          class="chat-hero__score"
          role="status"
          aria-live="polite"
          aria-label="Your current score"
        >
          <span class="chat-hero__score-label">Your Score</span>
          <span id="chat-score-value" class="chat-hero__score-value">0</span>
        </div>
      </div>
    </header>

    <section class="chat-layout">
      <aside class="chat-sidebar" aria-label="Chat preferences">
        <div id="notification-settings" class="chat-card chat-card--accent">
          <div class="chat-card__header">
            <span class="chat-card__eyebrow">Notifications</span>
            <h2 class="chat-card__title">Stay in the loop</h2>
          </div>
          <p id="notification-status" class="chat-card__muted">Checking permissions‚Ä¶</p>
          <button
            id="notification-toggle"
            class="chat-button"
            type="button"
            onclick="toggleNotifications()"
          >Enable Notifications</button>
        </div>

        <div id="profile-mini" class="chat-card" aria-live="polite">
          <div class="chat-card__header">
            <span class="chat-card__eyebrow">Profile</span>
            <h2 class="chat-card__title">Your identity</h2>
          </div>
          <p class="chat-card__muted">Signed in as</p>
          <p class="chat-card__value"><span id="current-username">Loading...</span></p>
          <p class="chat-card__hint">Visit your <a href="profile.html">profile</a> to update details.</p>
        </div>

        <div id="room-select" class="chat-card">
          <div class="chat-card__header">
            <span class="chat-card__eyebrow">Rooms</span>
            <h2 class="chat-card__title">Choose a channel</h2>
          </div>
          <label class="chat-card__muted" for="room">Switch between focused conversations.</label>
          <div class="chat-room-select">
            <select id="room" onchange="changeRoom()">
              <option value="general">üåé General</option>
              <option value="ideas">üí° Ideas</option>
              <option value="support">üõü Support</option>
              <option value="random">üé≤ Random</option>
            </select>
          </div>
          <p id="room-description" class="chat-card__hint">All-hands updates and daily announcements.</p>
        </div>
      </aside>

      <section class="chat-main" aria-label="Chat messages">
        <div class="chat-card chat-main__header">
          <div class="chat-main__header-text">
            <h2 class="chat-main__title">Now chatting</h2>
            <p class="chat-main__room" id="active-room-name">#general</p>
          </div>
          <p class="chat-main__subtitle" id="active-room-description">All-hands updates and daily announcements.</p>
        </div>

        <div class="chat-card chat-main__body">
          <form
            id="new-message"
            class="chat-composer"
            onsubmit="sendMessage(); return false;"
            aria-label="Send a message"
          >
            <label class="sr-only" for="message-input">Message</label>
            <input
              type="text"
              id="message-input"
              name="message"
              placeholder="Type your message..."
              autocomplete="off"
              required
            />
            <button type="submit" class="chat-button chat-button--primary">Send</button>
          </form>
          <div
            id="messages"
            class="chat-messages"
            role="log"
            aria-live="polite"
            aria-relevant="additions"
          ></div>
        </div>
      </section>
    </section>
  </main>

  <footer class="chat-footer">
    3DVR.Tech &copy; 2025 - Open Web for Everyone | Visit <a href="https://3dvr.tech">3DVR.Tech</a> | <a href="https://github.com/tmsteph/3dvr-portal">Contribute on GitHub</a>
  </footer>

<script>
const gun = Gun(window.__GUN_PEERS__ || [
  'wss://relay.3dvr.tech/gun',
  'wss://gun-relay-3dvr.fly.dev/gun'
]);
const portalRoot = gun.get('3dvr-portal');
const gunSupportsUser = typeof gun.user === 'function';
const portalUser = gunSupportsUser ? gun.user() : null;
const scoreManager = window.ScoreSystem && typeof window.ScoreSystem.getManager === 'function'
  ? window.ScoreSystem.getManager({
      gun: gunSupportsUser ? gun : null,
      user: portalUser,
      portalRoot
    })
  : null;
let currentRoom = 'general';
let chat = gun.get('3dvr-chat').get(currentRoom);

const activeRoomNameEl = document.getElementById('active-room-name');
const activeRoomDescriptionEl = document.getElementById('active-room-description');
const roomDescriptionEl = document.getElementById('room-description');
const roomSelectEl = document.getElementById('room');
const chatScoreContainer = document.getElementById('chat-score');
const chatScoreValueEl = document.getElementById('chat-score-value');
const chatFloatingMetaEl = document.getElementById('chat-floating-meta');
const chatFloatingUsernameEl = document.getElementById('chat-floating-username');
const chatFloatingScoreValueEl = document.getElementById('chat-floating-score-value');
const ROOM_DETAILS = {
  general: {
    label: '#general',
    description: 'All-hands updates and daily announcements.'
  },
  ideas: {
    label: '#ideas',
    description: 'Brainstorm new concepts and pitch future experiments.'
  },
  support: {
    label: '#support',
    description: 'Request a hand, squash bugs, and keep teammates unblocked.'
  },
  random: {
    label: '#random',
    description: 'Celebrate wins, share memes, and connect between sprints.'
  }
};

function sanitizeScoreDisplay(value) {
  if (window.ScoreSystem && typeof window.ScoreSystem.sanitizeScore === 'function') {
    return window.ScoreSystem.sanitizeScore(value);
  }
  const numeric = typeof value === 'number' ? value : Number(value);
  if (!Number.isFinite(numeric)) return 0;
  return Math.max(0, Math.round(numeric));
}

function updateChatScoreDisplay(value) {
  const safeScore = sanitizeScoreDisplay(value);
  if (chatScoreValueEl) {
    chatScoreValueEl.innerText = safeScore;
  }
  if (chatScoreContainer) {
    chatScoreContainer.setAttribute('data-ready', 'true');
  }
  if (chatFloatingScoreValueEl) {
    chatFloatingScoreValueEl.innerText = safeScore;
  }
  if (chatFloatingMetaEl) {
    chatFloatingMetaEl.setAttribute('data-ready', 'true');
  }
}

if (chatScoreContainer && chatScoreValueEl) {
  if (scoreManager && typeof scoreManager.subscribe === 'function') {
    scoreManager.subscribe(updateChatScoreDisplay);
  } else {
    updateChatScoreDisplay(0);
  }
}

const notificationToggleButton = document.getElementById('notification-toggle');
const notificationStatusText = document.getElementById('notification-status');
const notificationsSupported = 'Notification' in window;
const notificationsPreferenceKey = 'chatNotificationsEnabled';
const notificationIconPath = '/icons/icon-192.png';
const notificationStateStorageKey = 'chatNotificationState';
const INITIAL_SYNC_GRACE_MS = 1500;
let notificationsEnabled = false;
let serviceWorkerRegistration = null;
let currentRoomStream = null;
const roomInitialSyncTimers = {};
const notifiedMessageIdsByRoom = {};
const notifiedMessageQueueByRoom = {};

const CHAT_USER_ROOT = '3dvr-users';
const CHAT_GUEST_ROOT = '3dvr-guests';

function safeGetStorage(key) {
  try {
    return localStorage.getItem(key) || '';
  } catch (error) {
    console.warn(`Unable to read ${key} from storage`, error);
    return '';
  }
}

function safeSetStorage(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch (error) {
    console.warn(`Unable to store ${key} in storage`, error);
  }
}

function safeRemoveStorage(key) {
  try {
    localStorage.removeItem(key);
  } catch (error) {
    console.warn(`Unable to remove ${key} from storage`, error);
  }
}

function resolveChatIdentity() {
  try {
    const signedIn = safeGetStorage('signedIn') === 'true';
    let guestId = '';

    if (!signedIn) {
      if (window.ScoreSystem && typeof window.ScoreSystem.ensureGuestIdentity === 'function') {
        guestId = window.ScoreSystem.ensureGuestIdentity() || '';
      }

      if (!guestId) {
        guestId = safeGetStorage('guestId').trim();
      }

      if (!guestId) {
        const legacyId = safeGetStorage('userId').trim();
        if (legacyId) {
          guestId = legacyId;
          safeSetStorage('guestId', guestId);
          safeRemoveStorage('userId');
        }
      }

      if (guestId) {
        safeSetStorage('guest', 'true');
        if (!safeGetStorage('guestDisplayName')) {
          safeSetStorage('guestDisplayName', 'Guest');
        }
        return {
          id: guestId,
          type: 'guest',
          profileRoot: CHAT_GUEST_ROOT,
          storageKey: 'guestId'
        };
      }
    }

    let storedUserId = safeGetStorage('userId').trim();
    if (!storedUserId) {
      const prefix = signedIn ? 'user' : 'guest';
      storedUserId = `${prefix}_${Math.random().toString(36).substr(2, 9)}`;
      safeSetStorage('userId', storedUserId);
    }

    return {
      id: storedUserId,
      type: signedIn ? 'user' : 'legacy',
      profileRoot: CHAT_USER_ROOT,
      storageKey: 'userId'
    };
  } catch (error) {
    console.warn('Failed to resolve chat identity', error);
  }

  const fallbackId = `user_${Math.random().toString(36).substr(2, 9)}`;
  return {
    id: fallbackId,
    type: 'legacy',
    profileRoot: CHAT_USER_ROOT,
    storageKey: 'userId'
  };
}

function fetchSenderUsername(senderId, handler) {
  if (typeof handler !== 'function') return;
  if (!senderId) {
    handler('');
    return;
  }

  const readGuestName = callback => {
    gun.get(CHAT_GUEST_ROOT).get(senderId).get('username').once(name => {
      const normalized = typeof name === 'string' ? name.trim() : '';
      callback(normalized);
    });
  };

  const readUserName = callback => {
    gun.get(CHAT_USER_ROOT).get(senderId).get('username').once(name => {
      const normalized = typeof name === 'string' ? name.trim() : '';
      callback(normalized);
    });
  };

  const looksLikeGuest = typeof senderId === 'string' && senderId.startsWith('guest_');
  const firstReader = looksLikeGuest ? readGuestName : readUserName;
  const fallbackReader = looksLikeGuest ? readUserName : readGuestName;

  firstReader(name => {
    if (name) {
      handler(name);
      return;
    }
    fallbackReader(fallbackName => {
      handler(fallbackName || '');
    });
  });
}

function updateRoomUI(room) {
  const details = ROOM_DETAILS[room] || {};
  if (activeRoomNameEl) {
    activeRoomNameEl.textContent = details.label || `#${room}`;
  }
  if (activeRoomDescriptionEl) {
    activeRoomDescriptionEl.textContent = details.description || 'Chat with the community.';
  }
  if (roomDescriptionEl) {
    roomDescriptionEl.textContent = details.description || 'Chat with the community.';
  }
  if (roomSelectEl && roomSelectEl.value !== room) {
    roomSelectEl.value = room;
  }
}

function loadNotificationState() {
  try {
    const raw = localStorage.getItem(notificationStateStorageKey);
    if (!raw) {
      return { rooms: {} };
    }

    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') {
      return { rooms: {} };
    }

    if (!parsed.rooms || typeof parsed.rooms !== 'object') {
      parsed.rooms = {};
    }

    Object.keys(parsed.rooms).forEach(room => {
      const roomState = parsed.rooms[room];
      if (!roomState || typeof roomState !== 'object') {
        parsed.rooms[room] = {
          lastSeenTimestamp: 0,
          lastSeenMessageIds: [],
          initialSync: true,
          initialSyncCutoff: 0
        };
        return;
      }

      if (typeof roomState.lastSeenTimestamp !== 'number' || !Number.isFinite(roomState.lastSeenTimestamp)) {
        roomState.lastSeenTimestamp = 0;
      }

      if (!Array.isArray(roomState.lastSeenMessageIds)) {
        roomState.lastSeenMessageIds = [];
      }

      roomState.initialSync = Boolean(roomState.initialSync);
      roomState.initialSyncCutoff = typeof roomState.initialSyncCutoff === 'number'
        ? roomState.initialSyncCutoff
        : 0;
    });

    return parsed;
  } catch (error) {
    console.warn('Unable to load notification state', error);
    return { rooms: {} };
  }
}

const notificationState = loadNotificationState();

function persistNotificationState() {
  try {
    localStorage.setItem(notificationStateStorageKey, JSON.stringify(notificationState));
  } catch (error) {
    console.warn('Failed to persist notification state', error);
  }
}

function getRoomNotificationState(room) {
  if (!notificationState.rooms || typeof notificationState.rooms !== 'object') {
    notificationState.rooms = {};
  }

  if (!notificationState.rooms[room]) {
    notificationState.rooms[room] = {
      lastSeenTimestamp: 0,
      lastSeenMessageIds: [],
      initialSync: true,
      initialSyncCutoff: 0
    };
  } else {
    const roomState = notificationState.rooms[room];
    if (typeof roomState.lastSeenTimestamp !== 'number' || !Number.isFinite(roomState.lastSeenTimestamp)) {
      roomState.lastSeenTimestamp = 0;
    }
    if (!Array.isArray(roomState.lastSeenMessageIds)) {
      roomState.lastSeenMessageIds = [];
    }
    if (typeof roomState.initialSync !== 'boolean') {
      roomState.initialSync = true;
    }
    if (typeof roomState.initialSyncCutoff !== 'number' || !Number.isFinite(roomState.initialSyncCutoff)) {
      roomState.initialSyncCutoff = 0;
    }
  }

  return notificationState.rooms[room];
}

function updateRoomStateWithMessage(roomState, createdAt, id) {
  if (!roomState) return;

  const timestamp = typeof createdAt === 'number' && Number.isFinite(createdAt)
    ? createdAt
    : 0;

  if (!timestamp) {
    if (id) {
      const ids = roomState.lastSeenMessageIds;
      if (!ids.includes(id)) {
        ids.push(id);
        if (ids.length > 10) {
          ids.splice(0, ids.length - 10);
        }
      }
    }
    return;
  }

  if (!roomState.lastSeenTimestamp || timestamp > roomState.lastSeenTimestamp) {
    roomState.lastSeenTimestamp = timestamp;
    roomState.lastSeenMessageIds = id ? [id] : [];
    return;
  }

  if (timestamp === roomState.lastSeenTimestamp && id) {
    const ids = roomState.lastSeenMessageIds;
    if (!ids.includes(id)) {
      ids.push(id);
      if (ids.length > 10) {
        ids.splice(0, ids.length - 10);
      }
    }
  }
}

function clearInitialSyncTimer(room) {
  const timer = roomInitialSyncTimers[room];
  if (timer) {
    clearTimeout(timer);
    delete roomInitialSyncTimers[room];
  }
}

function beginRoomNotificationSync(room) {
  const roomState = getRoomNotificationState(room);
  roomState.initialSync = true;
  roomState.initialSyncCutoff = Date.now();
  persistNotificationState();

  clearInitialSyncTimer(room);
  roomInitialSyncTimers[room] = setTimeout(() => {
    const state = getRoomNotificationState(room);
    state.initialSync = false;
    state.initialSyncCutoff = 0;
    if (!state.lastSeenTimestamp || state.lastSeenTimestamp < Date.now()) {
      state.lastSeenTimestamp = Math.max(state.lastSeenTimestamp || 0, Date.now());
      if (!Array.isArray(state.lastSeenMessageIds)) {
        state.lastSeenMessageIds = [];
      }
    }
    persistNotificationState();
  }, INITIAL_SYNC_GRACE_MS);
}

const MAX_TRACKED_NOTIFICATIONS = 200;

function hasMessageBeenNotified(room, id) {
  if (!id) return false;
  const set = notifiedMessageIdsByRoom[room];
  return set ? set.has(id) : false;
}

function markMessageNotified(room, id) {
  if (!id) return;

  if (!notifiedMessageIdsByRoom[room]) {
    notifiedMessageIdsByRoom[room] = new Set();
    notifiedMessageQueueByRoom[room] = [];
  }

  const set = notifiedMessageIdsByRoom[room];
  const queue = notifiedMessageQueueByRoom[room];

  if (set.has(id)) return;

  set.add(id);
  queue.push(id);

  if (queue.length > MAX_TRACKED_NOTIFICATIONS) {
    const oldest = queue.shift();
    if (oldest) {
      set.delete(oldest);
    }
  }
}

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', event => {
    if (event.data && event.data.type === 'notification-clicked') {
      window.focus();
    }
  });
}

const currentUsernameEl = document.getElementById('current-username');
let cachedUsername = '';

const chatIdentity = resolveChatIdentity();
const userId = chatIdentity.id;
const isGuestIdentity = chatIdentity.type === 'guest';
const chatProfile = gun.get(chatIdentity.profileRoot).get(userId);

// Auto import old chats into General (only runs if in General and no messages exist)
if (currentRoom === 'general') {
  gun.get('3dvr-chat').map().once((message, id) => {
    if (!message) return;
    chat.get(id).once(existing => {
      if (!existing) {
        chat.get(id).put(message);
        console.log('Imported old message:', id);
      }
    });
  });
}

const initialUsername = derivePreferredUsername();
applyUsernameToUI(initialUsername);

if (chatProfile && typeof chatProfile.get === 'function') {
  chatProfile.get('username').once(existingName => {
    const resolvedName = derivePreferredUsername(existingName);
    applyUsernameToUI(resolvedName);
    const normalizedExisting = typeof existingName === 'string' ? existingName.trim() : '';
    if (normalizedExisting !== resolvedName) {
      chatProfile.get('username').put(resolvedName);
    }
  });

  chatProfile.get('username').on(name => {
    const normalized = typeof name === 'string' ? name.trim() : '';
    if (!normalized) return;
    applyUsernameToUI(normalized);
  });
}

function applyUsernameToUI(name) {
  const normalized = typeof name === 'string' ? name.trim() : '';
  const finalName = normalized || 'Guest';
  cachedUsername = finalName;
  if (normalized) {
    if (isGuestIdentity) {
      safeSetStorage('guestDisplayName', normalized);
    } else {
      safeSetStorage('username', normalized);
    }
  } else {
    if (isGuestIdentity) {
      safeSetStorage('guestDisplayName', 'Guest');
    } else {
      safeRemoveStorage('username');
    }
  }
  if (currentUsernameEl) {
    currentUsernameEl.innerText = finalName;
  }
  if (chatFloatingUsernameEl) {
    chatFloatingUsernameEl.innerText = finalName;
  }
}

function derivePreferredUsername(existingName) {
  const normalizedExisting = typeof existingName === 'string' ? existingName.trim() : '';
  const storedGuestName = isGuestIdentity ? safeGetStorage('guestDisplayName').trim() : '';
  const storedUsername = safeGetStorage('username').trim();

  if (isGuestIdentity && storedGuestName) {
    return storedGuestName;
  }

  if (!isGuestIdentity && storedUsername) {
    return storedUsername;
  }

  const aliasValue = safeGetStorage('alias').trim();
  const aliasName = aliasValue
    ? (aliasValue.includes('@') ? aliasValue.split('@')[0] : aliasValue)
    : '';

  if (aliasName && (!normalizedExisting || isGeneratedName(normalizedExisting))) {
    return aliasName;
  }

  if (normalizedExisting) return normalizedExisting;

  if (aliasName) return aliasName;

  if (isGuestIdentity && storedGuestName) {
    return storedGuestName;
  }

  const suffix = extractIdSuffix(userId);
  const baseLabel = 'Guest';
  return suffix ? `${baseLabel} ${suffix}` : baseLabel;
}

function extractIdSuffix(id) {
  if (!id) return '';
  const parts = id.split('_');
  const lastPart = parts[parts.length - 1] || '';
  return lastPart.slice(-4).toUpperCase();
}

function isGeneratedName(name) {
  if (!name) return false;
  const lower = name.toLowerCase();
  return lower === 'guest' ||
    lower.startsWith('guest ') ||
    lower.startsWith('guest_') ||
    lower === 'user' ||
    lower.startsWith('user ') ||
    lower.startsWith('user_');
}

function sendMessage() {
  const input = document.getElementById('message-input');
  const text = input.value.trim();
  if (!text) return;

  chat.set({
    text,
    sender: userId,
    username: cachedUsername,
    createdAt: Date.now()
  });

  input.value = '';

  if (scoreManager) {
    scoreManager.increment(1);
  }
}

const messages = {};

function resetNotifiedStateForRoom(room) {
  if (!room) return;
  const set = notifiedMessageIdsByRoom[room];
  const queue = notifiedMessageQueueByRoom[room];
  if (set) {
    set.clear();
  }
  if (queue) {
    queue.length = 0;
  }
}

function timeAgoOrFullDate(timestamp) {
  const now = Date.now();
  const diff = Math.floor((now - timestamp) / 1000);
  if (diff < 60) return `${diff}s ago`;
  const mins = Math.floor(diff / 60);
  if (mins < 60) return `${mins}m ago`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `${hrs}h ago`;
  const date = new Date(timestamp);
  return date.toLocaleString(undefined, { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' });
}

function displayMessages() {
  const messagesDiv = document.getElementById('messages');
  messagesDiv.innerHTML = '';

  const sorted = Object.entries(messages).sort(([, a], [, b]) => (b.createdAt || 0) - (a.createdAt || 0));
  for (const [id, message] of sorted) {
    const msgDiv = document.createElement('div');
    msgDiv.className = 'message';
    msgDiv.id = id;

    const username = (typeof message.username === 'string' ? message.username.trim() : '') ||
      (message.sender || 'Anonymous');
    const time = message.createdAt ? timeAgoOrFullDate(message.createdAt) : '';

    msgDiv.innerHTML = `<div><strong>${username}:</strong> ${message.text}</div><div class="meta">${time}</div>`;
    messagesDiv.appendChild(msgDiv);
  }

  if (!sorted.length) {
    const emptyState = document.createElement('p');
    emptyState.className = 'chat-empty';
    emptyState.textContent = 'No messages yet. Start the conversation!';
    messagesDiv.appendChild(emptyState);
  }
}

function loadRoom(roomName) {
  const messagesDiv = document.getElementById('messages');
  messagesDiv.innerHTML = '';
  Object.keys(messages).forEach(key => delete messages[key]);
  resetNotifiedStateForRoom(roomName);
  beginRoomNotificationSync(roomName);

  if (currentRoomStream && typeof currentRoomStream.off === 'function') {
    currentRoomStream.off();
  }

  chat = gun.get('3dvr-chat').get(roomName);
  const roomStream = chat.map();
  currentRoomStream = roomStream;

  roomStream.on((message, id) => {
    if (!message || messages[id]) return;

    if (message.sender) {
      const existingUsername = typeof message.username === 'string'
        ? message.username.trim()
        : '';
      if (existingUsername) {
        message.username = existingUsername;
        messages[id] = message;
        displayMessages();
        maybeNotifyNewMessage(message, id);
        return;
      }

      fetchSenderUsername(message.sender, resolvedName => {
        const finalName = resolvedName || message.sender;
        message.username = finalName;
        messages[id] = message;
        displayMessages();
        maybeNotifyNewMessage(message, id);
      });
    } else {
      messages[id] = message;
      displayMessages();
      maybeNotifyNewMessage(message, id);
    }
  });
}

function changeRoom() {
  const select = roomSelectEl || document.getElementById('room');
  currentRoom = select ? select.value : currentRoom;
  updateRoomUI(currentRoom);
  loadRoom(currentRoom);
}

updateRoomUI(currentRoom);
loadRoom(currentRoom);

function initNotifications() {
  if (!notificationToggleButton || !notificationStatusText) return;

  if (!notificationsSupported) {
    notificationToggleButton.style.display = 'none';
    notificationStatusText.textContent = 'Notifications are not supported in this browser.';
    return;
  }

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        serviceWorkerRegistration = registration;
        return registration;
      })
      .catch(() => navigator.serviceWorker.register('/service-worker.js', { scope: '/' }))
      .then((registration) => {
        if (registration) {
          serviceWorkerRegistration = registration;
        }
      })
      .catch((error) => {
        console.error('Service worker registration failed for chat notifications', error);
      });
  }

  const savedPreference = localStorage.getItem(notificationsPreferenceKey) === 'true';
  if (savedPreference && Notification.permission === 'granted') {
    notificationsEnabled = true;
  }

  updateNotificationUI();
}

function updateNotificationUI() {
  if (!notificationToggleButton || !notificationStatusText) return;

  if (!notificationsSupported) {
    notificationToggleButton.style.display = 'none';
    notificationStatusText.textContent = 'Notifications are not supported in this browser.';
    return;
  }

  if (Notification.permission === 'denied') {
    notificationToggleButton.disabled = true;
    notificationStatusText.textContent = 'Notifications are blocked in your browser settings.';
    return;
  }

  notificationToggleButton.disabled = false;
  notificationToggleButton.textContent = notificationsEnabled ? 'Disable Notifications' : 'Enable Notifications';

  if (notificationsEnabled && Notification.permission === 'granted') {
    notificationStatusText.textContent = 'Notifications are on. We will alert you about new messages.';
  } else {
    notificationStatusText.textContent = 'Notifications are off. Click enable to stay updated.';
  }
}

function toggleNotifications() {
  if (!notificationsSupported) return;

  if (notificationsEnabled) {
    notificationsEnabled = false;
    localStorage.setItem(notificationsPreferenceKey, 'false');
    updateNotificationUI();
    return;
  }

  if (Notification.permission === 'granted') {
    notificationsEnabled = true;
    localStorage.setItem(notificationsPreferenceKey, 'true');
    updateNotificationUI();
    sendNotificationPreview();
    return;
  }

  Notification.requestPermission().then(permission => {
    notificationsEnabled = permission === 'granted';
    localStorage.setItem(notificationsPreferenceKey, notificationsEnabled ? 'true' : 'false');

    if (permission === 'denied') {
      notificationStatusText.textContent = 'Notifications are blocked in your browser settings.';
    }

    updateNotificationUI();

    if (permission === 'granted') {
      sendNotificationPreview();
    }
  });
}

async function attemptServiceWorkerNotification(registration, title, options) {
  if (!registration) return false;

  try {
    if (registration.active && typeof registration.active.postMessage === 'function') {
      registration.active.postMessage({
        type: 'show-notification',
        payload: { title, options }
      });
      return true;
    }

    if (typeof registration.showNotification === 'function') {
      await registration.showNotification(title, options);
      return true;
    }
  } catch (error) {
    console.error('Service worker notification attempt failed', error);
  }

  return false;
}

async function showChatNotification(title, options = {}, config = {}) {
  if (!notificationsEnabled || !notificationsSupported) return;
  if (!title || Notification.permission !== 'granted') return;

  const { requireHidden = true } = config;
  if (requireHidden && document.visibilityState === 'visible') return;

  const enrichedOptions = {
    ...options,
    icon: options.icon || notificationIconPath,
    badge: options.badge || notificationIconPath,
    timestamp: Date.now(),
    data: {
      ...options.data,
      url: options.data?.url || `/chat.html#${currentRoom}`,
      room: currentRoom
    }
  };

  const fallbackToPageNotification = () => {
    try {
      const notification = new Notification(title, enrichedOptions);
      setTimeout(() => notification.close(), 8000);
    } catch (error) {
      console.error('Unable to show notification', error);
    }
  };

  if (!('serviceWorker' in navigator)) {
    fallbackToPageNotification();
    return;
  }

  if (await attemptServiceWorkerNotification(serviceWorkerRegistration, title, enrichedOptions)) {
    return;
  }

  try {
    const registration = await navigator.serviceWorker.ready;
    serviceWorkerRegistration = registration;

    const success = await attemptServiceWorkerNotification(registration, title, enrichedOptions);
    if (!success) {
      fallbackToPageNotification();
    }
  } catch (error) {
    console.error('Service worker readiness error', error);
    fallbackToPageNotification();
  }
}

function sendNotificationPreview() {
  showChatNotification(
    'Chat notifications enabled',
    {
      body: 'We will let you know when someone posts a new message.',
      tag: 'chat-notification-preview',
      data: { messageId: 'preview' }
    },
    { requireHidden: false }
  );
}

function maybeNotifyNewMessage(message, id) {
  if (!message || message.sender === userId) return;

  const roomState = getRoomNotificationState(currentRoom);
  const cutoff = roomState.initialSyncCutoff || 0;
  const createdAt = typeof message.createdAt === 'number' && Number.isFinite(message.createdAt)
    ? message.createdAt
    : null;

  if (roomState.initialSync) {
    const isHistorical = createdAt !== null && cutoff && createdAt <= cutoff;
    if (isHistorical) {
      updateRoomStateWithMessage(roomState, createdAt, id);
      markMessageNotified(currentRoom, id);
      persistNotificationState();
      return;
    }

    if (!createdAt && cutoff && Date.now() - cutoff < INITIAL_SYNC_GRACE_MS) {
      markMessageNotified(currentRoom, id);
      return;
    }

    roomState.initialSync = false;
    roomState.initialSyncCutoff = 0;
    persistNotificationState();
  }

  if (hasMessageBeenNotified(currentRoom, id)) {
    return;
  }

  const effectiveTimestamp = createdAt !== null ? createdAt : Date.now();
  const lastTimestamp = roomState.lastSeenTimestamp || 0;
  const ids = Array.isArray(roomState.lastSeenMessageIds)
    ? roomState.lastSeenMessageIds
    : (roomState.lastSeenMessageIds = []);

  if (createdAt !== null) {
    if (effectiveTimestamp < lastTimestamp) {
      return;
    }

    if (effectiveTimestamp === lastTimestamp && ids.includes(id)) {
      return;
    }
  }

  const username = (typeof message.username === 'string' ? message.username.trim() : '') ||
    message.sender ||
    'Someone';

  const rawPreview = typeof message.text === 'string'
    ? message.text.trim()
    : String(message.text || '').trim();
  const notificationBody = rawPreview.length > 160 ? `${rawPreview.slice(0, 157)}...` : rawPreview;

  const title = `${username} in #${currentRoom}`;
  const options = {
    body: notificationBody || 'New message',
    tag: `${currentRoom}-${id}`,
    data: {
      messageId: id
    }
  };

  showChatNotification(title, options, { requireHidden: true });
  markMessageNotified(currentRoom, id);
  updateRoomStateWithMessage(roomState, effectiveTimestamp, id);
  persistNotificationState();
}

initNotifications();
</script>

</body>
</html>
