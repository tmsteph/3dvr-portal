<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3DVR Admin Portal</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="/gun-init.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <style>
  :root {
    color-scheme: light;
    --bg: #f4f7fb;
    --card-bg: #ffffff;
    --text-primary: #1e2a3b;
    --text-secondary: #4f5b6a;
    --accent: #2f80ed;
    --accent-soft: rgba(47, 128, 237, 0.1);
    --danger: #d64550;
    --success: #27ae60;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: var(--bg);
    color: var(--text-primary);
    min-height: 100vh;
    padding: 20px;
    display: flex;
    align-items: stretch;
    justify-content: center;
  }

  .page {
    width: min(1100px, 100%);
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  header {
    background: linear-gradient(135deg, #0f172a, #1e3a8a);
    color: white;
    padding: 24px;
    border-radius: 16px;
    box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
  }

  header h1 {
    margin: 0 0 8px;
    font-size: clamp(1.5rem, 2vw + 1rem, 2.4rem);
  }

  header p {
    margin: 0;
    color: rgba(255, 255, 255, 0.88);
  }

  .status-message {
    border-radius: 12px;
    padding: 16px 18px;
    background: var(--accent-soft);
    color: var(--text-secondary);
    border: 1px solid rgba(47, 128, 237, 0.2);
    display: none;
  }

  .status-message.show {
    display: block;
  }

  .card {
    background: var(--card-bg);
    border-radius: 14px;
    padding: 20px;
    box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
  }

  .text-muted {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }

  .metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 16px;
  }

  .metric-card {
    border: 1px solid rgba(15, 23, 42, 0.08);
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .metric-card h3 {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-secondary);
  }

  .metric-value {
    font-size: 2rem;
    font-weight: 600;
    color: var(--accent);
  }

  .table-wrapper {
    overflow-x: auto;
    border-radius: 12px;
    border: 1px solid rgba(15, 23, 42, 0.08);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    min-width: 640px;
  }

  thead {
    background: #eef3fb;
    color: var(--text-secondary);
    font-weight: 600;
  }

  th, td {
    padding: 14px 16px;
    text-align: left;
    border-bottom: 1px solid rgba(15, 23, 42, 0.08);
    font-size: 0.95rem;
  }

  tbody tr:hover {
    background: rgba(47, 128, 237, 0.06);
  }

  .empty-state {
    text-align: center;
    padding: 18px;
    color: var(--text-secondary);
    font-style: italic;
  }

  .list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 8px;
  }

  .list-item {
    border: 1px solid rgba(15, 23, 42, 0.08);
    border-radius: 12px;
    padding: 14px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    background: rgba(255, 255, 255, 0.86);
  }

  .list-item .info {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .list-item .info span {
    color: var(--text-secondary);
    font-size: 0.85rem;
  }

  .leaderboard {
    list-style: none;
    padding: 0;
    margin: 8px 0 0;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .leaderboard-item {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 12px;
    align-items: center;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid rgba(15, 23, 42, 0.08);
    background: rgba(255, 255, 255, 0.9);
  }

  .leaderboard-rank {
    font-weight: 700;
    color: var(--accent);
    font-size: 1.1rem;
  }

  .leaderboard-info {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .leaderboard-info span {
    color: var(--text-secondary);
    font-size: 0.9rem;
  }

  .leaderboard-points {
    font-weight: 700;
    color: var(--text-primary);
  }

  .actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  .stripe-status {
    margin-top: 10px;
    color: var(--text-secondary);
    font-size: 0.9rem;
  }

  button {
    border: none;
    border-radius: 10px;
    padding: 10px 16px;
    font-weight: 600;
    cursor: pointer;
    font-family: inherit;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .btn-primary {
    background: var(--accent);
    color: white;
    box-shadow: 0 10px 20px rgba(47, 128, 237, 0.2);
  }

  .btn-primary:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 12px 24px rgba(47, 128, 237, 0.3);
  }

  .btn-outline {
    background: white;
    color: var(--text-primary);
    border: 1px solid rgba(15, 23, 42, 0.12);
  }

  .btn-danger {
    background: var(--danger);
    color: white;
    box-shadow: 0 10px 20px rgba(214, 69, 80, 0.18);
  }

  .form-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  label {
    font-weight: 600;
    color: var(--text-secondary);
  }

  input, textarea {
    border-radius: 10px;
    border: 1px solid rgba(15, 23, 42, 0.12);
    padding: 10px 12px;
    font-family: inherit;
    font-size: 1rem;
    background: rgba(255, 255, 255, 0.9);
  }

  textarea {
    resize: vertical;
    min-height: 90px;
  }

  .hidden {
    display: none !important;
  }

  @media (max-width: 640px) {
    body {
      padding: 16px;
    }

    .list-item {
      flex-direction: column;
      align-items: flex-start;
    }

    .actions {
      width: 100%;
      justify-content: flex-start;
    }
  }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>3DVR Admin Portal</h1>
      <p>Monitor community metrics and manage trusted administrators.</p>
    </header>

    <div id="status" class="status-message"></div>

    <section id="request-card" class="card hidden" aria-live="polite">
      <h2>Request Admin Access</h2>
      <p id="request-status" class="text-muted"></p>
      <div class="form-group">
        <label for="request-reason">Why should you be an admin?</label>
        <textarea id="request-reason" placeholder="Share a quick note for tmsteph"></textarea>
      </div>
      <div class="actions">
        <button id="request-button" class="btn-primary" type="button">Submit Request</button>
      </div>
    </section>

    <section id="dashboard" class="hidden" aria-live="polite">
      <div class="card">
        <h2>Community Snapshot</h2>
        <div class="metrics">
          <div class="card metric-card">
            <h3>Total Registered Users</h3>
            <div id="total-users" class="metric-value">--</div>
          </div>
          <div class="card metric-card">
            <h3>Total Points Awarded</h3>
            <div id="total-points" class="metric-value">--</div>
          </div>
          <div class="card metric-card">
            <h3>Pending Admin Requests</h3>
            <div id="pending-count" class="metric-value">--</div>
          </div>
        </div>
      </div>

      <div class="card" id="defaults-card">
        <h2>Workbench Shared Defaults</h2>
        <p class="text-muted">Encrypt shared defaults for OpenAI, Vercel, and GitHub. Teams can unlock them with a passphrase and stay within the shared rate limits.</p>
        <div class="form-group">
          <label for="default-api-key">Default OpenAI API key</label>
          <input id="default-api-key" type="password" placeholder="sk-..." />
        </div>
        <div class="form-group">
          <label for="default-vercel-token">Default Vercel token</label>
          <input id="default-vercel-token" type="password" placeholder="Vercel access token" />
        </div>
        <div class="form-group">
          <label for="default-github-token">Default GitHub token</label>
          <input id="default-github-token" type="password" placeholder="GitHub personal access token" />
        </div>
        <div class="form-group">
          <label for="default-api-passphrase">Encryption passphrase</label>
          <input id="default-api-passphrase" type="password" placeholder="Required to encrypt and decrypt" />
          <p class="text-muted">Passphrase is never stored; share it privately with the team so they can unlock the defaults without exposing the raw tokens publicly.</p>
        </div>
        <div class="form-group">
          <label for="default-api-hint">Passphrase hint (optional)</label>
          <input id="default-api-hint" type="text" placeholder="Example: same passphrase as portal admin" />
        </div>
        <div class="actions" style="margin-top: 10px;">
          <button id="save-default-key" class="btn-primary" type="button">Save defaults</button>
          <button id="clear-default-key" class="btn-danger" type="button">Clear defaults</button>
        </div>
        <p id="default-status" class="text-muted"></p>
      </div>

      <div class="card">
        <h2>Leaderboard</h2>
        <p class="text-muted">Top 10 users ranked by total points.</p>
        <ol id="leaderboard" class="leaderboard" aria-live="polite">
          <li class="empty-state">Waiting for leaderboard data...</li>
        </ol>
      </div>

      <div class="card">
        <div class="actions" style="justify-content: space-between; align-items: center;">
          <div>
            <h2 style="margin: 0 0 4px;">Stripe Subscriber Leaderboard</h2>
            <p class="text-muted" style="margin: 0;">100 points per dollar spent across paid invoices.</p>
          </div>
          <button id="stripe-refresh" class="btn-primary" type="button">Refresh from Stripe</button>
        </div>
        <div class="table-wrapper" style="margin-top: 12px;">
          <table aria-label="Stripe subscriber leaderboard">
            <thead>
              <tr>
                <th scope="col">Rank</th>
                <th scope="col">Subscriber</th>
                <th scope="col">Email</th>
                <th scope="col">Amount Spent</th>
                <th scope="col">Points</th>
                <th scope="col">Last Invoice</th>
              </tr>
            </thead>
            <tbody id="stripe-customer-table">
              <tr class="empty-state">
                <td colspan="6">Waiting for Stripe data...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p id="stripe-status" class="stripe-status"></p>
      </div>

      <div class="card">
        <h2>User Points Overview</h2>
        <div class="table-wrapper">
          <table aria-describedby="total-users">
            <thead>
              <tr>
                <th scope="col">Username</th>
                <th scope="col">Alias</th>
                <th scope="col">Points</th>
                <th scope="col">Last Updated</th>
                <th scope="col">Last Login</th>
                <th scope="col" id="user-actions-header" class="hidden">Actions</th>
              </tr>
            </thead>
            <tbody id="user-table">
              <tr class="empty-state">
                <td colspan="6">Awaiting user data...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="card" id="recovery-card">
        <h2>Account Recovery</h2>
        <p class="text-muted">Reset usernames and issue temporary passwords for users who lost access.</p>
        <div class="form-group">
          <label for="recovery-current">Current account</label>
          <input id="recovery-current" type="text" placeholder="username or alias to recover" />
        </div>
        <div class="form-group">
          <label for="recovery-username">New username</label>
          <input id="recovery-username" type="text" placeholder="new username (creates a fresh alias)" />
        </div>
        <div class="form-group">
          <label for="recovery-password">Temporary password</label>
          <input id="recovery-password" type="password" placeholder="share with the user so they can sign in" />
        </div>
        <div class="actions" style="margin-top: 10px;">
          <button id="recovery-button" class="btn-primary" type="button">Reset credentials</button>
        </div>
        <p id="recovery-status" class="text-muted"></p>
      </div>

      <div class="card">
        <h2>Current Admins</h2>
        <div id="admin-list" class="list" aria-live="polite"></div>
        <div id="add-admin" class="hidden" style="margin-top: 16px;">
          <h3>Promote a new admin</h3>
          <p class="text-muted">Enter a username or alias (ex: tmsteph or tmsteph@3dvr).</p>
          <div class="form-group">
            <label for="new-admin">Account</label>
            <input id="new-admin" type="text" placeholder="username or alias" />
          </div>
          <div class="actions" style="margin-top: 10px;">
            <button id="add-admin-button" class="btn-primary" type="button">Add Admin</button>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Admin Requests</h2>
        <div id="request-list" class="list" aria-live="polite"></div>
      </div>
    </section>
  </div>

  <script>
  const gun = Gun({
    peers: window.__GUN_PEERS__ || [
      'wss://relay.3dvr.tech/gun',
      'wss://gun-relay-3dvr.fly.dev/gun'
    ]
  });
  const user = gun.user();
  const portalRoot = gun.get('3dvr-portal');
  const portalAdmins = portalRoot.get('admins');
  const adminRequests = portalRoot.get('adminRequests');
  const userIndex = portalRoot.get('userIndex');
  const userStats = portalRoot.get('userStats');
  const userDeletionLog = portalRoot.get('userDeletions');
  const workbenchDefaults = portalRoot.get('ai-workbench').get('defaults');
  // Stripe subscriber summaries live under finance/stripeCustomers to keep shared totals in GunJS.
  const stripeCustomersNode = portalRoot.get('finance').get('stripeCustomers');
  const accountRecoveryLog = portalRoot.get('accountRecovery');

  const alias = localStorage.getItem('alias');
  const password = localStorage.getItem('password');
  const username = localStorage.getItem('username');

  const ROOT_ADMIN_ALIAS = 'tmsteph@3dvr';

  const userRecords = {};
  const pointsRecords = {};
  const stripeCustomerRecords = {};
  const adminRecords = {};
  const requestRecords = {};
  let defaultRecord = {};

  let isAdmin = false;
  let isRootAdmin = false;

  const statusEl = document.getElementById('status');
  const dashboardEl = document.getElementById('dashboard');
  const requestCardEl = document.getElementById('request-card');
  const requestStatusEl = document.getElementById('request-status');
  const requestButton = document.getElementById('request-button');
  const requestReason = document.getElementById('request-reason');
  const userTable = document.getElementById('user-table');
  const totalUsersEl = document.getElementById('total-users');
  const totalPointsEl = document.getElementById('total-points');
  const pendingCountEl = document.getElementById('pending-count');
  const adminListEl = document.getElementById('admin-list');
  const addAdminSection = document.getElementById('add-admin');
  const addAdminInput = document.getElementById('new-admin');
  const addAdminButton = document.getElementById('add-admin-button');
  const requestListEl = document.getElementById('request-list');
  const leaderboardEl = document.getElementById('leaderboard');
  const stripeTableEl = document.getElementById('stripe-customer-table');
  const stripeStatusEl = document.getElementById('stripe-status');
  const stripeRefreshBtn = document.getElementById('stripe-refresh');
  const defaultsCard = document.getElementById('defaults-card');
  const defaultKeyInput = document.getElementById('default-api-key');
  const defaultVercelInput = document.getElementById('default-vercel-token');
  const defaultGithubInput = document.getElementById('default-github-token');
  const defaultPassphraseInput = document.getElementById('default-api-passphrase');
  const defaultHintInput = document.getElementById('default-api-hint');
  const defaultStatusEl = document.getElementById('default-status');
  const saveDefaultKeyBtn = document.getElementById('save-default-key');
  const clearDefaultKeyBtn = document.getElementById('clear-default-key');
  const recoveryCard = document.getElementById('recovery-card');
  const recoveryCurrentInput = document.getElementById('recovery-current');
  const recoveryUsernameInput = document.getElementById('recovery-username');
  const recoveryPasswordInput = document.getElementById('recovery-password');
  const recoveryButton = document.getElementById('recovery-button');
  const recoveryStatusEl = document.getElementById('recovery-status');
  const userActionsHeader = document.getElementById('user-actions-header');

  function init() {
    ensureRootAdmin();

    if (!alias || !password) {
      setStatus('Please sign in to manage the admin portal.');
      showElement(requestCardEl);
      requestCardEl.querySelector('textarea').disabled = true;
      requestButton.disabled = true;
      return;
    }

    setStatus('Verifying admin credentials...');
    user.auth(alias, password, ack => {
      if (ack.err) {
        setStatus('Authentication failed. Please sign in again.');
        localStorage.removeItem('signedIn');
        return;
      }
      checkAdminStatus();
    });
  }

  function ensureRootAdmin() {
    portalAdmins.get(ROOT_ADMIN_ALIAS).once(data => {
      if (!data) {
        portalAdmins.get(ROOT_ADMIN_ALIAS).put({
          alias: ROOT_ADMIN_ALIAS,
          username: 'tmsteph',
          addedAt: Date.now(),
          addedBy: 'system'
        });
      }
    });
  }

  function checkAdminStatus() {
    portalAdmins.get(alias).once(data => {
      isAdmin = Boolean(data);
      isRootAdmin = alias === ROOT_ADMIN_ALIAS;

      if (isAdmin) {
        setStatus('');
        showDashboard();
      } else {
        showRequestForm();
      }
    });
  }

  function showDashboard() {
    hideElement(requestCardEl);
    showElement(dashboardEl);
    if (isAdmin) {
      showElement(defaultsCard);
    } else {
      hideElement(defaultsCard);
    }
    if (isRootAdmin) {
      showElement(addAdminSection);
    }
    subscribeToData();
  }

  function showRequestForm() {
    showElement(requestCardEl);
    hideElement(dashboardEl);
    requestButton.disabled = false;
    requestCardEl.querySelector('textarea').disabled = false;
    requestStatusEl.innerText = 'Only existing admins can approve new admins. Your request will be sent to tmsteph.';
    adminRequests.get(alias).once(data => {
      if (!data) return;
      requestStatusEl.innerText = buildRequestMessage(data);
      requestReason.value = data.reason || '';
      const status = data.status || 'pending';
      if (status === 'pending' || status === 'approved') {
        requestButton.disabled = true;
        requestReason.disabled = true;
      }
    });
  }

  function subscribeToData() {
    userIndex.map().on((data, key) => {
      if (!key) return;
      if (!data) {
        delete userRecords[key];
      } else {
        userRecords[key] = {
          ...userRecords[key],
          ...data
        };
      }
      renderUsers();
    });

    userStats.map().on((data, key) => {
      if (!key) return;
      if (!data) {
        delete pointsRecords[key];
      } else {
        pointsRecords[key] = {
          ...pointsRecords[key],
          ...data
        };
      }
      renderUsers();
    });

    portalAdmins.map().on((data, key) => {
      if (!key) return;
      if (!data) {
        delete adminRecords[key];
      } else {
        adminRecords[key] = {
          ...adminRecords[key],
          ...data
        };
      }
      renderAdmins();
    });

    adminRequests.map().on((data, key) => {
      if (!key) return;
      if (!data) {
        delete requestRecords[key];
      } else {
        requestRecords[key] = {
          ...requestRecords[key],
          ...data
        };
      }
      renderRequests();
    });

    stripeCustomersNode.map().on((data, key) => {
      if (!key) return;
      if (!data) {
        delete stripeCustomerRecords[key];
      } else {
        stripeCustomerRecords[key] = normalizeStripeRecord({
          ...stripeCustomerRecords[key],
          ...data
        });
      }
      renderStripeCustomers();
    });

    if (isAdmin) {
      workbenchDefaults.on(data => {
        defaultRecord = data || {};
        renderDefaults();
      });
    }
  }

  function renderUsers() {
    const aliasSet = new Set([
      ...Object.keys(userRecords),
      ...Object.keys(pointsRecords)
    ]);
    const aliases = Array.from(aliasSet);
    const showActions = Boolean(isAdmin);
    const columnCount = showActions ? 6 : 5;

    if (userActionsHeader) {
      userActionsHeader.classList.toggle('hidden', !showActions);
    }

    if (!aliases.length) {
      userTable.innerHTML = `<tr class="empty-state"><td colspan="${columnCount}">No registered users yet.</td></tr>`;
      totalUsersEl.innerText = '0';
      totalPointsEl.innerText = '0';
      return;
    }

    const rows = aliases.map(id => {
      const profile = userRecords[id] || {};
      const stats = pointsRecords[id] || {};
      return {
        alias: id,
        username: profile.username || stats.username || id.replace('@3dvr', ''),
        points: Number(stats.points || 0),
        lastUpdated: stats.lastUpdated,
        lastLogin: profile.lastLogin,
        createdAt: profile.createdAt,
        archived: Boolean(profile.archived || stats.archived)
      };
    });

    const activeRows = rows.filter(record => !record.archived);
    activeRows.sort((a, b) => b.points - a.points);

    const totalPoints = activeRows.reduce((sum, item) => sum + (item.points || 0), 0);
    totalUsersEl.innerText = activeRows.length.toString();
    totalPointsEl.innerText = totalPoints.toString();

    userTable.innerHTML = activeRows.map(record => {
      const actions = showActions ? `
        <td>
          <div class="actions">
            <button
              class="btn-danger"
              data-action="delete-user"
              data-alias="${escapeAttr(record.alias)}"
              data-username="${escapeAttr(record.username)}"
            >Delete</button>
          </div>
        </td>
      ` : '';

      return `
        <tr>
          <td>${escapeHtml(record.username)}</td>
          <td>${escapeHtml(record.alias)}</td>
          <td>${record.points}</td>
          <td>${formatDate(record.lastUpdated)}</td>
          <td>${formatDate(record.lastLogin)}</td>
          ${actions}
        </tr>
      `;
    }).join('');

    if (showActions) {
      userTable.querySelectorAll('button[data-action="delete-user"]').forEach(button => {
        button.addEventListener('click', () => {
          const targetAlias = button.dataset.alias;
          const targetName = button.dataset.username;
          confirmUserDeletion(targetAlias, targetName);
        });
      });
    }

    renderLeaderboard(activeRows);
  }

  function renderLeaderboard(rows) {
    if (!rows.length) {
      leaderboardEl.innerHTML = '<li class="empty-state">No leaderboard data yet.</li>';
      return;
    }

    const topTen = rows.slice(0, 10);
    leaderboardEl.innerHTML = topTen.map((record, index) => {
      const rank = index + 1;
      const badge = rank === 1 ? 'ðŸ¥‡' : rank === 2 ? 'ðŸ¥ˆ' : rank === 3 ? 'ðŸ¥‰' : `#${rank}`;
      return `
        <li class="leaderboard-item">
          <div class="leaderboard-rank">${badge}</div>
          <div class="leaderboard-info">
            <strong>${escapeHtml(record.username)}</strong>
            <span>${escapeHtml(record.alias)}</span>
          </div>
          <div class="leaderboard-points">${record.points} pts</div>
        </li>
      `;
    }).join('');
  }

  function renderStripeCustomers() {
    const records = Object.values(stripeCustomerRecords)
      .map(normalizeStripeRecord)
      .filter(item => typeof item.amountPaid === 'number' && !Number.isNaN(item.amountPaid))
      .sort((a, b) => b.amountPaid - a.amountPaid);

    if (!records.length) {
      stripeTableEl.innerHTML = '<tr class="empty-state"><td colspan="6">No Stripe subscribers yet.</td></tr>';
      return;
    }

    stripeTableEl.innerHTML = records.map((record, index) => {
      const dollars = (record.amountPaid || 0) / 100;
      const points = Math.round(dollars * 100);
      const rank = index + 1;
      const email = escapeHtml(record.email || 'â€”');
      const name = escapeHtml(record.name || 'â€”');
      const lastInvoice = record.lastInvoiceAt ? formatDate(record.lastInvoiceAt) : 'â€”';
      const currency = (record.currency || 'USD').toUpperCase();
      const formatter = new Intl.NumberFormat('en-US', { style: 'currency', currency });

      return `
        <tr>
          <td>${rank}</td>
          <td>${name}</td>
          <td>${email}</td>
          <td>${formatter.format(dollars)}</td>
          <td>${points.toLocaleString()} pts</td>
          <td>${lastInvoice}</td>
        </tr>
      `;
    }).join('');
  }

  function renderAdmins() {
    const entries = Object.values(adminRecords)
      .filter(Boolean)
      .sort((a, b) => (b.addedAt || 0) - (a.addedAt || 0));

    if (!entries.length) {
      adminListEl.innerHTML = '<div class="empty-state">No admins have been recorded yet.</div>';
      return;
    }

    adminListEl.innerHTML = entries.map(item => {
      const who = item.addedBy === 'system' ? 'system' : escapeHtml(item.addedBy || 'unknown');
      return `
        <div class="list-item">
          <div class="info">
            <strong>${escapeHtml(item.username || item.alias || '')}</strong>
            <span>${escapeHtml(item.alias || '')}</span>
            <span>Added ${formatDate(item.addedAt)} by ${who}</span>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderRequests() {
    const entries = Object.entries(requestRecords)
      .map(([key, value]) => ({ key, ...value }))
      .sort((a, b) => (b.requestedAt || 0) - (a.requestedAt || 0));

    const pending = entries.filter(item => item.status === 'pending' || !item.status);
    pendingCountEl.innerText = pending.length.toString();

    if (!entries.length) {
      requestListEl.innerHTML = '<div class="empty-state">No admin requests so far.</div>';
      return;
    }

    requestListEl.innerHTML = entries.map(item => {
      const status = item.status || 'pending';
      const badges = {
        pending: '<span style="color: var(--accent); font-weight: 600;">Pending</span>',
        approved: '<span style="color: var(--success); font-weight: 600;">Approved</span>',
        denied: '<span style="color: var(--danger); font-weight: 600;">Denied</span>'
      };
      const actions = isRootAdmin && status === 'pending' ? `
        <div class="actions">
          <button class="btn-primary" data-action="approve" data-alias="${escapeAttr(item.key)}">Approve</button>
          <button class="btn-outline" data-action="deny" data-alias="${escapeAttr(item.key)}">Deny</button>
        </div>
      ` : '';

      const reviewed = item.reviewedBy ? `<span>Reviewed by ${escapeHtml(item.reviewedBy)} on ${formatDate(item.reviewedAt)}</span>` : '';

      return `
        <div class="list-item">
          <div class="info">
            <strong>${escapeHtml(item.username || item.alias || '')}</strong>
            <span>${escapeHtml(item.alias || '')}</span>
            <span>${badges[status] || status}</span>
            ${item.reason ? `<span>Reason: ${escapeHtml(item.reason)}</span>` : ''}
            <span>Requested on ${formatDate(item.requestedAt)}</span>
            ${reviewed}
          </div>
          ${actions}
        </div>
      `;
    }).join('');

    if (isRootAdmin) {
      requestListEl.querySelectorAll('button[data-action]').forEach(button => {
        button.addEventListener('click', event => {
          const action = event.currentTarget.dataset.action;
          const targetAlias = event.currentTarget.dataset.alias;
          if (action === 'approve') {
            approveRequest(targetAlias);
          } else if (action === 'deny') {
            denyRequest(targetAlias);
          }
        });
      });
    }
  }

  function renderDefaults() {
    if (!defaultStatusEl) return;
    const available = [];
    if (defaultRecord.apiKeyCipher) available.push('OpenAI');
    if (defaultRecord.vercelTokenCipher) available.push('Vercel');
    if (defaultRecord.githubTokenCipher) available.push('GitHub');

    if (!available.length) {
      defaultStatusEl.innerText = 'No defaults have been saved yet.';
      return;
    }

    const updated = formatDate(defaultRecord.updatedAt);
    const updatedBy = escapeHtml(defaultRecord.updatedBy || 'admin');
    const hint = defaultRecord.hint ? `Hint: ${escapeHtml(defaultRecord.hint)}` : 'No hint set.';
    defaultStatusEl.innerHTML = [
      `Encrypted defaults saved by ${updatedBy} on ${updated}.`,
      `Available: ${available.join(', ')}.`,
      hint,
      'Shared keys are rate limited per identity.'
    ].join(' ');
  }

  function updateDefaultStatus(message) {
    if (defaultStatusEl) {
      defaultStatusEl.innerText = message;
    }
  }

  function setRecoveryStatus(message, tone = 'muted') {
    if (!recoveryStatusEl) return;
    recoveryStatusEl.innerText = message;
    if (tone === 'error') {
      recoveryStatusEl.style.color = 'var(--danger)';
    } else if (tone === 'success') {
      recoveryStatusEl.style.color = 'var(--success)';
    } else {
      recoveryStatusEl.style.color = 'var(--text-secondary)';
    }
  }

  function sanitizePointsValue(value) {
    const numeric = typeof value === 'number' ? value : Number(value);
    if (!Number.isFinite(numeric)) return 0;
    return Math.max(0, Math.round(numeric));
  }

  function readNodeValue(node, key) {
    return new Promise(resolve => {
      if (!node || typeof node.get !== 'function') {
        resolve(null);
        return;
      }
      node.get(key).once(data => resolve(data || null));
    });
  }

  async function handleAccountRecovery() {
    if (!recoveryButton) return;
    if (!isAdmin) {
      setRecoveryStatus('Only admins can reset credentials.', 'error');
      return;
    }

    const targetAlias = normalizeAlias((recoveryCurrentInput.value || '').trim());
    const nextUsername = (recoveryUsernameInput.value || '').trim();
    const nextAlias = normalizeAlias(nextUsername);
    const tempPassword = (recoveryPasswordInput.value || '').trim();

    if (!targetAlias) {
      setRecoveryStatus('Enter the existing username or alias to recover.', 'error');
      return;
    }
    if (!nextUsername) {
      setRecoveryStatus('Add the new username you want to issue.', 'error');
      return;
    }
    if (!tempPassword || tempPassword.length < 6) {
      setRecoveryStatus('Use a temporary password with at least 6 characters.', 'error');
      return;
    }
    if (!gun || gun.__isGunStub) {
      setRecoveryStatus('Gun peers are offline. Try again once connected.', 'error');
      return;
    }
    if (targetAlias === nextAlias) {
      setRecoveryStatus('Choose a new username so a fresh alias can be created.', 'error');
      return;
    }

    setRecoveryStatus('Looking up the account and preparing a reset...');
    recoveryButton.disabled = true;

    const [profile, stats] = await Promise.all([
      readNodeValue(userIndex, targetAlias),
      readNodeValue(userStats, targetAlias)
    ]);

    if (!profile && !stats) {
      setRecoveryStatus('No account metadata found for that user.', 'error');
      recoveryButton.disabled = false;
      return;
    }

    const issuedAt = Date.now();
    const currentUsername = profile?.username || stats?.username || targetAlias.replace('@3dvr', '');
    const points = sanitizePointsValue(stats?.points);
    const lastUpdated = stats?.lastUpdated || issuedAt;
    const createdAt = profile?.createdAt || issuedAt;
    const lastLogin = profile?.lastLogin || 0;

    setRecoveryStatus('Creating the new account and transferring metadata...');
    const creationUser = typeof gun.user === 'function' ? gun.user() : null;
    if (!creationUser || typeof creationUser.create !== 'function') {
      setRecoveryStatus('Gun user instance unavailable. Refresh and try again.', 'error');
      recoveryButton.disabled = false;
      return;
    }

    const creationAck = await new Promise(resolve => {
      try {
        creationUser.create(nextAlias, tempPassword, ack => resolve(ack || {}));
      } catch (error) {
        resolve({ err: error?.message || 'account-creation-failed' });
      }
    });

    if (creationAck && creationAck.err) {
      const message = String(creationAck.err || '').includes('User already created')
        ? 'That new username already exists. Pick a different username.'
        : `Could not create the new account: ${creationAck.err}`;
      setRecoveryStatus(message, 'error');
      recoveryButton.disabled = false;
      return;
    }

    userIndex.get(nextAlias).put({
      username: nextUsername,
      alias: nextAlias,
      createdAt,
      lastLogin,
      recoveredFrom: targetAlias,
      recoveredAt: issuedAt
    });

    userStats.get(nextAlias).put({
      username: nextUsername,
      alias: nextAlias,
      points,
      lastUpdated,
      recoveredFrom: targetAlias,
      recoveredAt: issuedAt
    });

    userIndex.get(targetAlias).put({
      archived: true,
      recoveredTo: nextAlias,
      recoveredAt: issuedAt
    });
    userStats.get(targetAlias).put({
      archived: true,
      recoveredTo: nextAlias,
      recoveredAt: issuedAt
    });

    accountRecoveryLog.get(`${targetAlias}-${issuedAt}`).put({
      targetAlias,
      newAlias: nextAlias,
      issuedBy: alias,
      issuedAt,
      pointsTransferred: points,
      previousUsername: currentUsername
    });

    setRecoveryStatus(`New credentials ready. Username: ${nextUsername}. Temporary password: ${tempPassword}.`, 'success');
    recoveryButton.disabled = false;
    recoveryCurrentInput.value = '';
    recoveryUsernameInput.value = '';
    recoveryPasswordInput.value = '';
  }

  async function saveDefaultKey() {
    if (!isAdmin) {
      updateDefaultStatus('Only admins can change shared defaults.');
      return;
    }

    const apiKey = (defaultKeyInput.value || '').trim();
    const vercelToken = (defaultVercelInput.value || '').trim();
    const githubToken = (defaultGithubInput.value || '').trim();
    const passphrase = (defaultPassphraseInput.value || '').trim();
    const hint = (defaultHintInput.value || '').trim();

    if (!apiKey && !vercelToken && !githubToken) {
      updateDefaultStatus('Enter at least one API token to save.');
      return;
    }

    if (!passphrase || passphrase.length < 6) {
      updateDefaultStatus('Add a passphrase (6+ characters) to encrypt the defaults.');
      return;
    }

    if (!Gun.SEA || typeof Gun.SEA.encrypt !== 'function') {
      updateDefaultStatus('Gun SEA not available. Please refresh and try again.');
      return;
    }

    updateDefaultStatus('Encrypting and saving shared defaults...');

    try {
      const cipher = apiKey ? await Gun.SEA.encrypt(apiKey, passphrase) : null;
      const vercelCipher = vercelToken ? await Gun.SEA.encrypt(vercelToken, passphrase) : null;
      const githubCipher = githubToken ? await Gun.SEA.encrypt(githubToken, passphrase) : null;
      const payload = {
        apiKeyCipher: cipher,
        vercelTokenCipher: vercelCipher,
        githubTokenCipher: githubCipher,
        hint,
        updatedAt: Date.now(),
        updatedBy: alias || 'admin'
      };
      workbenchDefaults.put(payload, ack => {
        if (ack?.err) {
          updateDefaultStatus('Could not save the defaults.');
          return;
        }
        defaultKeyInput.value = '';
        defaultVercelInput.value = '';
        defaultGithubInput.value = '';
        updateDefaultStatus('Defaults saved. Share the passphrase privately with your team.');
      });
    } catch (error) {
      updateDefaultStatus('Failed to encrypt the defaults.');
    }
  }

  function clearDefaultKey() {
    if (!isAdmin) return;

    workbenchDefaults.put({
      apiKeyCipher: null,
      vercelTokenCipher: null,
      githubTokenCipher: null,
      hint: '',
      updatedAt: Date.now(),
      updatedBy: alias || 'admin'
    }, ack => {
      if (ack?.err) {
        updateDefaultStatus('Unable to clear the default key.');
        return;
      }
      defaultRecord = {};
      defaultKeyInput.value = '';
      defaultVercelInput.value = '';
      defaultGithubInput.value = '';
      defaultPassphraseInput.value = '';
      defaultHintInput.value = '';
      updateDefaultStatus('Defaults cleared.');
    });
  }

  function approveRequest(targetAlias) {
    const record = requestRecords[targetAlias];
    if (!record) return;
    promoteToAdmin(targetAlias, record);
    adminRequests.get(targetAlias).get('status').put('approved');
    adminRequests.get(targetAlias).get('reviewedBy').put(alias);
    adminRequests.get(targetAlias).get('reviewedAt').put(Date.now());
    setStatus(`${targetAlias} is now an admin.`);
  }

  function denyRequest(targetAlias) {
    adminRequests.get(targetAlias).get('status').put('denied');
    adminRequests.get(targetAlias).get('reviewedBy').put(alias);
    adminRequests.get(targetAlias).get('reviewedAt').put(Date.now());
    setStatus(`Denied admin request for ${targetAlias}.`);
  }

  function promoteToAdmin(targetAlias, record) {
    const cleanAlias = normalizeAlias(targetAlias);
    const displayName = record?.username || cleanAlias.replace('@3dvr', '');
    portalAdmins.get(cleanAlias).put({
      alias: cleanAlias,
      username: displayName,
      addedAt: Date.now(),
      addedBy: alias
    });
  }

  function confirmUserDeletion(targetAlias, targetName) {
    if (!isAdmin) {
      setStatus('Only admins can delete users.');
      return;
    }

    const normalizedAlias = normalizeAlias(targetAlias);
    const displayName = targetName || normalizedAlias.replace('@3dvr', '');
    const confirmationMessage = [
      `Delete ${displayName} (${normalizedAlias})?`,
      'This removes their profile, points, and admin records.'
    ].join(' ');
    const confirmed = window.confirm(confirmationMessage);

    if (!confirmed) return;
    deleteUser(normalizedAlias, displayName);
  }

  function deleteUser(normalizedAlias, displayName) {
    const deletionAt = Date.now();
    const stats = pointsRecords[normalizedAlias] || {};
    const auditRecord = {
      alias: normalizedAlias,
      username: displayName,
      pointsAtDeletion: sanitizePointsValue(stats.points),
      deletedAt: deletionAt,
      deletedBy: alias || 'admin'
    };

    // Remove portal metadata for the deleted user and record the deletion event for traceability.
    userDeletionLog.get(`${normalizedAlias}-${deletionAt}`).put(auditRecord);
    userIndex.get(normalizedAlias).put(null);
    userStats.get(normalizedAlias).put(null);
    portalAdmins.get(normalizedAlias).put(null);
    adminRequests.get(normalizedAlias).put(null);

    setStatus(`${displayName} removed from portal records.`);
  }

  function setStatus(message) {
    if (!message) {
      statusEl.classList.remove('show');
      statusEl.innerText = '';
      return;
    }
    statusEl.classList.add('show');
    statusEl.innerText = message;
  }

  function showElement(element) {
    element.classList.remove('hidden');
  }

  function hideElement(element) {
    element.classList.add('hidden');
  }

  function formatDate(timestamp) {
    if (!timestamp) return 'â€”';
    try {
      return new Date(Number(timestamp)).toLocaleString();
    } catch (error) {
      return 'â€”';
    }
  }

  function escapeHtml(value) {
    return (value || '').toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function escapeAttr(value) {
    return escapeHtml(value).replace(/`/g, '&#96;');
  }

  function normalizeAlias(value) {
    if (!value) return '';
    const trimmed = value.trim();
    return trimmed.includes('@') ? trimmed : `${trimmed}@3dvr`;
  }

  function normalizeStripeRecord(record = {}) {
    const amountPaid = Number(record.amountPaid);
    const invoiceCount = Number(record.invoiceCount);
    const currency = (record.currency || 'USD').toUpperCase();

    return {
      ...record,
      aggregateKey: record.aggregateKey || record.email || record.customerId || '',
      amountPaid: Number.isNaN(amountPaid) ? 0 : amountPaid,
      invoiceCount: Number.isNaN(invoiceCount) ? 0 : invoiceCount,
      currency,
      lastInvoiceAt: record.lastInvoiceAt || null,
      name: record.name || '',
      email: record.email || ''
    };
  }

  function buildRequestMessage(data) {
    const status = data.status || 'pending';
    if (status === 'approved') {
      return 'Your admin request has already been approved.';
    }
    if (status === 'denied') {
      return 'Your admin request was declined. Contact tmsteph for more details.';
    }
    return 'You already have a pending request. We will notify tmsteph.';
  }

  async function refreshStripeCustomers() {
    if (!isAdmin) {
      setStatus('Only admins can refresh Stripe subscriber data.');
      return;
    }

    stripeStatusEl.innerText = 'Fetching latest Stripe subscribers...';
    stripeRefreshBtn.disabled = true;

    try {
      const response = await fetch('/api/stripe/customers');
      if (!response.ok) {
        stripeStatusEl.innerText = 'Unable to load Stripe customers right now.';
        return;
      }

      const payload = await response.json();
      const customers = payload.customers || [];
      const updatedAt = Date.now();
      const nextKeys = new Set();

      customers.forEach(record => {
        const key = record.aggregateKey || record.email || record.customerId || `customer-${Math.random()}`;
        nextKeys.add(key);
        stripeCustomerRecords[key] = normalizeStripeRecord({ ...record, aggregateKey: record.aggregateKey || key });
        renderStripeCustomers();
        stripeCustomersNode.get(key).put({
          customerId: record.customerId || key,
          aggregateKey: record.aggregateKey || key,
          customerIds: record.customerIds || [],
          email: record.email || '',
          name: record.name || '',
          currency: (record.currency || 'USD').toUpperCase(),
          amountPaid: Number(record.amountPaid || 0),
          invoiceCount: Number(record.invoiceCount || 0),
          lastInvoiceAt: record.lastInvoiceAt || null,
          updatedAt
        });
      });

      Object.keys(stripeCustomerRecords).forEach(existingKey => {
        if (!nextKeys.has(existingKey)) {
          stripeCustomersNode.get(existingKey).put(null);
        }
      });

      stripeStatusEl.innerText = `Synced ${customers.length} subscribers from Stripe at ${formatDate(updatedAt)}.`;
    } catch (error) {
      stripeStatusEl.innerText = 'Failed to refresh Stripe data. Please try again.';
    } finally {
      stripeRefreshBtn.disabled = false;
    }
  }

  requestButton.addEventListener('click', () => {
    if (!alias) {
      setStatus('Please sign in before requesting admin access.');
      return;
    }
    const reason = requestReason.value.trim();
    adminRequests.get(alias).put({
      alias,
      username: username || alias.replace('@3dvr', ''),
      reason,
      status: 'pending',
      requestedAt: Date.now()
    });
    setStatus('Request submitted. tmsteph will review it soon.');
    requestButton.disabled = true;
    requestReason.disabled = true;
  });

  addAdminButton.addEventListener('click', () => {
    if (!isRootAdmin) return;
    const value = addAdminInput.value.trim();
    if (!value) {
      setStatus('Enter a username or alias to promote.');
      return;
    }
    const normalized = normalizeAlias(value);
    const reference = userRecords[normalized] || pointsRecords[normalized] || {};
    const displayName = reference.username || value.replace('@3dvr', '');
    portalAdmins.get(normalized).put({
      alias: normalized,
      username: displayName,
      addedAt: Date.now(),
      addedBy: alias
    });
    adminRequests.get(normalized).get('status').put('approved');
    adminRequests.get(normalized).get('reviewedBy').put(alias);
    adminRequests.get(normalized).get('reviewedAt').put(Date.now());
    addAdminInput.value = '';
    setStatus(`${displayName} promoted to admin.`);
  });

  if (recoveryButton) {
    recoveryButton.addEventListener('click', handleAccountRecovery);
  }
  saveDefaultKeyBtn.addEventListener('click', saveDefaultKey);
  clearDefaultKeyBtn.addEventListener('click', clearDefaultKey);
  stripeRefreshBtn.addEventListener('click', refreshStripeCustomers);

  window.addEventListener('load', init);
  </script>
</body>
</html>
